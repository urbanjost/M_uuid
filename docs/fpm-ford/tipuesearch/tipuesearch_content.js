var tipuesearch = {"pages":[{"title":" M_uuid ","text":"M_uuid Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"M_uuid.f90 – M_uuid","text":"Contents Modules M_uuid Source Code M_uuid.f90 Source Code module M_uuid !> !!##NAME !!    M_uuid(3f) - [M_uuid] a module of UUID (Universally Unique IDentifier) procedures !!    (LICENSE:CUSTOM OPEN) !! !!##SYNOPSIS !! !!    use m_uuid, only : generate_uuid !! !!##QUOTE !!    Remember you are unique, just like everyone else. !! !!##DESCRIPTION !! !!    A universally unique identifier (UUID) is a 128-bit number used to !!    identify information in computer systems. !! !!    When generated according to the standard methods, UUIDs are for !!    practical purposes unique, without depending for their uniqueness !!    on a central registration authority or coordination between the !!    parties generating them, unlike most other numbering schemes. While !!    the probability that a UUID will be duplicated is not zero, it is !!    close enough to zero to be negligible. !! !!    Thus, anyone can create a UUID and use it to identify something with !!    near certainty that the identifier does not duplicate one that has !!    already been or will be created to identify something else. Information !!    labeled with UUIDs by independent parties can therefore be later !!    combined into a single database, or transmitted on the same channel, !!    without needing to resolve conflicts between identifiers. !! !!    Adoption of UUIDs and GUIDs is widespread. Many computing platforms !!    provide support for generating them, and for parsing their textual !!    representation. !! !!    RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. !!    A UUID presented as a URN appears as follows: !! !!       urn:uuid:123e4567-e89b-12d3-a456-426655440000 !! !! -- Wikipedia !! !!##PROCEDURES !! !!    generate_uuid(version)   generate 36-character UUID string !=================================================================================================================================== use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , dp => real128 !! provide for routines extracted from other modules (M_time and M_random) implicit none integer , parameter :: realtime = kind ( 0.0d0 ) ! type for unix epoch time and julian days ! Kind types for IEEE 754/IEC 60559 single- and double-precision reals integer , parameter :: IEEE32 = selected_real_kind ( 6 , 37 ) integer , parameter :: IEEE64 = selected_real_kind ( 15 , 307 ) ! Constants integer ( INT32 ), parameter :: N = 624_INT32 integer ( INT32 ), parameter :: M = 397_INT32 real ( kind = realtime ), parameter , private :: SECDAY = 8640 0.0d0 ! 24:00:00 hours as seconds type mtprng_state integer ( INT32 ) :: mti = - 1 integer ( INT64 ), dimension ( 0 : N - 1 ) :: mt end type !=================================================================================================================================== !=================================================================================================================================== private ! ident_1=\"@(#)M_uuid::M_uid(3fm): generate UUIDs according to RFC 4122\" ! Only versions  0(Nil), 1 (time-based) and 4 (pseudo-RNG-based) are implemented. integer , parameter :: i4b = selected_int_kind ( 9 ) integer , parameter :: i8b = selected_int_kind ( 18 ) type ( mtprng_state ), save :: rng_state logical , save :: initialized = . false . integer , save :: values_save ! must be default for date_and_time integer ( kind = i4b ), save :: hires_count = 0 integer , save :: clock_seq = 0 ! a random number constant for the lifetime of the process. best we can do per S 4.1.5 public :: generate_uuid contains !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! !> !! ! generate_uuid(3f) was originally derived from the xmlf90 codebase, (c) Alberto Garcia & Jon Wakelin, 2003-2004. !! ! It also calls RNG routines from Scott Ladd <scott.ladd@coyotegulch.com>, and the libFoX modules. Although !! ! some sections have been replaced, generate_uuid(3f) was originally based on the libFoX version, with !! ! licensing as follows: !! ! !! ! (c) 2005-2009 Toby White <tow@uszla.me.uk> !! ! (c) 2007-2009 Gen-Tao Chiang <gtc25@cam.ac.uk> !! ! (c) 2008-2012 Andrew Walker <a.walker@ucl.ac.uk> !! ! !! ! All rights reserved. !! ! !! ! * Redistribution and use in source and binary forms, with or without !! ! modification, are permitted provided that the following conditions are !! ! met: !! ! !! ! * Redistributions of source code must retain the above copyright notice, !! ! this list of conditions and the following disclaimer. !! ! !! ! * Redistributions in binary form must reproduce the above copyright !! ! notice, this list of conditions and the following disclaimer in the !! ! documentation and/or other materials provided with the distribution. !! ! !! ! * Neither the name of the copyright holder nor the names of its !! ! contributors may be used to endorse or promote products derived from !! ! this software without specific prior written permission. !! ! !! ! !! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS !! ! \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT !! ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR !! ! A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT !! ! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, !! ! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT !! ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, !! ! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY !! ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT !! ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE !! ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !> !!##NAME !!    generate_uuid(3f) - [M_uuid] generate a UUID (Universally Unique IDentifier) string per RFC 4122 !!    (LICENSE:CUSTOM OPEN) !! !!##SYNOPSIS !! !!    function generate_uuid(version) result(uuid) !! !!     integer, intent(in), optional :: version !!     character(len=36) :: uuid !! !!##DESCRIPTION !!    A universally unique identifier (UUID) is a 128-bit number used to !!    identify information in computer systems. When generated according !!    to standard methods UUIDs are for practical purposes unique. !!    generate_uuid(3f) converts the UUID to a standard string format !!    per RFC 4122. !! !!##AUTHORS !!    based on previous work from Alberto Garcia & Jon Wakelin, 2003-2004. !!    RNG routines from Scott Ladd <scott.ladd@coyotegulch.com>, and !!    the libFoX library( Toby White <tow@uszla.me.uk>, Gen-Tao Chiang !!    <gtc25@cam.ac.uk>, Andrew Walker <a.walker@ucl.ac.uk>). !! !!##OPTIONS !!    version  Indicates which standard method as described in RFC 4122 !!             is used to generate the string. Versions 0,1, and 4 are supported. !! !!             0.  Nil UUID (ie. '00000000-0000-0000-0000-000000000000') !!             1.  time-based UUID !!             2.  Not implemented !!             3.  Not implemented !!             4.  pseudo-RNG(Random Number Generator) based !!             5.  Not implemented !! !!##EXAMPLE !! !!   Sample usage: !! !!    program demo_generate_uuid !!    use M_uuid, only : generate_uuid !!    implicit none !!    character(len=36) :: uuid !!       ! !!       uuid=generate_uuid(1)  ! version 1 (time-based UUID) !!       write(*,'(a36)')uuid !!       ! !!       uuid=generate_uuid(4)  ! version 4 (pseudo-RNG-based), default !!       ! !!       ! RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. !!       write(*,'(\"urn:uuid:\",a36)')uuid !!       ! !!       ! a good scratch file name !!       open(file='/tmp/scratch_'//uuid,unit=10) !!       ! !!    end program demo_generate_uuid !! !!   Typical output: !! !!     e769adf4-4af7-11e8-7421-3c9dfbfe9aab !!     urn:uuid:5b0946b8-0eb4-4966-619d-047b7f7e2056 function generate_uuid ( version ) result ( uuid ) ! ident_2=\"@(#)M_uuid::generate_uuid(3f): generate(approximately) a UUID (Universally Unique IDentifier) string per RFC 4122\" integer , intent ( in ), optional :: version character ( len = 36 ) :: uuid integer ( kind = i8b ) :: timestamp , node integer ( kind = i4b ) :: clock_sequence integer ( kind = i4b ) :: time_low , time_mid , time_hi_and_version integer ( kind = i4b ) :: clk_seq_hi_res , clk_seq_low integer :: values ( 8 ) ! must be default for date_and_time integer ( kind = i4b ) :: variant , v if (. not . initialized ) then ! Use the current date and time to init mtprng but this gives limited variability, so mix the result up. ! Can we do better? In any case, this gets passed through a quick generator inside mtprng_init. call date_and_time ( values = values ) values ( 7 ) = values ( 7 ) * 1000 + values ( 5 ) * 100 + values ( 3 ) * 10 + values ( 1 ) values ( 8 ) = values ( 2 ) * 1000 + values ( 4 ) * 100 + values ( 6 ) * 10 + values ( 8 ) call mtprng_init ( int ( values ( 7 ) * 10000 + values ( 8 ), i4b ), rng_state ) clock_seq = int ( mtprng_rand64 ( rng_state ), i4b ) initialized = . true . endif variant = 1 if ( present ( version )) then v = version else v = 4 endif select case ( v ) case ( 0 ) uuid = '00000000-0000-0000-0000-000000000000' ! Nil UUID return case ( 1 ) !  version 1(time-based) call date_and_time ( values = values ) ! In case of too-frequent requests, we will replace time_low with the count below ... if ( all ( values == values_save )) then hires_count = hires_count + 1 else hires_count = 0 endif timestamp = get_utc_since_1582 ( values ) clock_sequence = clock_seq ! clock sequence (14 bits) node = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 16 )) ! node ( 48 bits) ! No MAC address accessible - see section 4.5 !FIXME case ( 2 - 3 , 5 ) ! Unimplemented uuid = '' return case ( 4 ) ! version 4 (pseudo-RNG-based) timestamp = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 28 )) clock_sequence = int ( mtprng_rand64 ( rng_state ), i4b ) ! clock sequence (14 bits) node = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 16 )) ! node ( 48 bits) case default ! Unspecified uuid = '' return end select time_low = ibits ( timestamp , 0 , 32 ) time_mid = ibits ( timestamp , 32 , 16 ) if ( hires_count == 0 ) then time_hi_and_version = ior ( int ( ibits ( timestamp , 48 , 12 ), i4b ), ishft ( v , 12 )) else time_hi_and_version = ior ( hires_count , ishft ( v , 12 )) endif clk_seq_low = ibits ( clock_sequence , 0 , 8 ) clk_seq_hi_res = ior ( ibits ( clock_sequence , 8 , 6 ), ishft ( variant , 6 )) uuid = int32ToHexOctets ( time_low , 4 ) // \"-\" // & int32ToHexOctets ( time_mid , 2 ) // \"-\" // & int32ToHexOctets ( time_hi_and_version , 2 ) // \"-\" // & int32ToHexOctets ( clk_seq_hi_res , 1 ) // & int32ToHexOctets ( clk_seq_low , 1 ) // \"-\" // & int64ToHexOctets ( node , 6 ) contains !==================================================================================================================================! function int32ToHexOctets ( b , n ) result ( s ) integer ( i4b ), intent ( in ) :: b integer , intent ( in ) :: n ! number of octets to print character ( len = 2 * n ) :: s character , parameter :: hexdigits ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] integer :: i do i = 0 , 2 * n - 1 s ( 2 * n - i : 2 * n - i ) = hexdigits ( ibits ( b , i * 4 , 4 )) enddo end function int32ToHexOctets !==================================================================================================================================! function int64ToHexOctets ( b , n ) result ( s ) integer ( i8b ), intent ( in ) :: b integer , intent ( in ) :: n ! number of octets to print character ( len = 2 * n ) :: s character , parameter :: hexdigits ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] integer :: i do i = 0 , 2 * n - 1 s ( 2 * n - i : 2 * n - i ) = hexdigits ( ibits ( b , i * 4 , 4 )) enddo end function int64ToHexOctets !==================================================================================================================================! end function generate_uuid !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! function get_utc_since_1582 ( values ) result ( ns ) ! returns the number of 100-ns intervals since 1582-10-15T00:00:00-0 ! Not really: Assuming only used as an internal routine for M_UUID(3fm) !   Fortran date time arrays only report up to the millisecond, !   and assuming any date given is after 2017 (because added leapseconds up till that date) !   and not taking account of leapseconds after 2017, and assuming !   if get same answer on multiple calls that caller will correct or try again, as goal is to generate unique values integer , intent ( in ) :: values ( 8 ) integer ( kind = i8b ) :: ns real ( kind = realtime ) :: unixtime real ( kind = realtime ) :: starttime integer :: ierr integer :: clicks , maxclicks real :: rate real ( kind = dp ) :: rate8 , frac8 integer ( kind = i8b ) :: frac call date_to_unix ([ 1582 , 10 , 15 , 0 , 0 , 0 , 0 , 0 , 0 ], starttime , ierr ) ! seconds from 1582-10-15-00-00-00 to Unix Epoch Time call date_to_unix ( values , unixtime , ierr ) ! seconds from given date to Unix Epoch Time ! if system clock is higher resolution use it even though that makes fractional second wrong call system_clock ( count = clicks , count_rate = rate , count_max = maxclicks ) if ( rate . gt . 1000 ) then ! system clock available and higher resolution rate8 = real ( rate , kind = dp ) frac8 = mod ( real ( clicks , kind = dp ), rate8 ) / rate8 * 10000000_i8b ! MOD(A,P) == A - INT (A/P) * P. frac = int ( frac8 ) ! truncate to one remainder of one second ns = int (( unixtime - starttime ) * 10000000_i8b , kind = i8b ) + frac ! get date and time to nearest second and add frac else ! use date even though accurate only to 1/1000 second ns = int ( unixtime * 10000000_i8b , kind = i8b ) - int ( starttime * 10000000_i8b , kind = i8b ) endif ns = ns + 26_i8b ! leap seconds as of 2016 at 23:59:60 UTC end function get_utc_since_1582 !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! ! ROUTINES EXTRACTED FROM OTHER MODULES TO PROVIDE PORTABILITY !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    date_to_julian(3f) - [M_time:JULIAN] converts DAT date-time array to !!    Julian Date !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine date_to_julian(dat,juliandate,ierr) !! !!     integer,intent(in)               :: dat(8) !!     real(kind=realtime),intent(out)  :: juliandate !!     integer,intent(out)              :: ierr !! !!##DESCRIPTION !!    Converts a DAT date-time array to a Unix Epoch Time (UET) value. !!    UET is the number of seconds since 00:00 on January 1st, 1970, UTC. !! !!##OPTIONS !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!           dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !! !!##RETURNS !!    juliandate  A Julian Ephemeris Date (JED) is the number of days since !!                noon (not midnight) on January 1st, 4713 BC. !!    ierr        Error code. If 0 no error occurred. !! !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_date_to_julian !!     use M_time, only : date_to_julian,realtime !!     implicit none !!     integer             :: dat(8) !!     real(kind=realtime) :: juliandate !!     integer             :: ierr !!        ! generate DAT array !!        call date_and_time(values=dat) !!        ! show DAT array !!        write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!        ! convert DAT to Julian Date !!        call date_to_julian(dat,juliandate,ierr) !!        write(*,*)'Julian Date is ',juliandate !!        write(*,*)'ierr is ',ierr !!     end program demo_date_to_julian !! !!    results: !! !!     Today is:2016:7:19:-240:11:3:13:821 !!     Julian Date is    2457589.1272432986 !!     ierr is            0 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine date_to_julian ( dat , julian , ierr ) !----------------------------------------------------------------------------------------------------------------------------------- !> !! AUTHOR:    John S. Urban !!##VERSION:   1.0 2015-12-21 !! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19 ! * There is no year zero ! * Julian Date must be non-negative ! * Julian Date starts at noon; while Civil Calendar date starts at midnight !----------------------------------------------------------------------------------------------------------------------------------- ! ident_3=\"@(#)M_time::date_to_julian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date\" integer , intent ( in ) :: dat ( 8 ) ! array like returned by DATE_AND_TIME(3f) real ( kind = realtime ), intent ( out ) :: julian ! Julian Date (non-negative, but may be non-integer) integer , intent ( out ) :: ierr ! Error return: 0 =successful execution,-1=invalid year,-2=invalid month,-3=invalid day ! -4=invalid date (29th Feb, non leap-year) integer :: year , month , day , utc , hour , minute real ( kind = realtime ) :: second integer :: A , Y , M , JDN !----------------------------------------------------------------------------------------------------------------------------------- year = dat ( 1 ) ! Year month = dat ( 2 ) ! Month day = dat ( 3 ) ! Day utc = dat ( 4 ) * 60 ! Delta from UTC, convert from minutes to seconds hour = dat ( 5 ) ! Hour minute = dat ( 6 ) ! Minute second = dat ( 7 ) - utc + dat ( 8 ) / 100 0.0d0 ! Second   ! correction for time zone and milliseconds !----------------------------------------------------------------------------------------------------------------------------------- julian = - HUGE ( 99999 ) ! this is the date if an error occurs and IERR is < 0 !----------------------------------------------------------------------------------------------------------------------------------- if ( year == 0 . or . year . lt . - 4713 ) then ierr =- 1 return endif !----------------------------------------------------------------------------------------------------------------------------------- !  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) A = ( 14 - month ) / 12 ! A will be 1 for January or February, and 0 for other months, with integer truncation Y = year + 4800 - A M = month + 12 * A - 3 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero !  Staring from a Gregorian calendar date JDN = day + ( 153 * M + 2 ) / 5 + 365 * Y + Y / 4 - Y / 100 + Y / 400 - 32045 !  with integer truncation !  Finding the Julian Calendar date given the JDN (Julian day number) and time of day julian = JDN + dble ( hour - 12 ) / 2 4.0d0 + dble ( minute ) / 144 0.0d0 + second / 8640 0.0d0 !----------------------------------------------------------------------------------------------------------------------------------- if ( julian . lt . 0.d0 ) then ! Julian Day must be non-negative ierr = 1 else ierr = 0 endif !----------------------------------------------------------------------------------------------------------------------------------- end subroutine date_to_julian !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    date_to_unix(3f) - [M_time:UNIX_EPOCH] converts DAT date-time array to Unix !!    Epoch Time !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine date_to_unix(dat,unixtime,ierr) !! !!     integer,intent(in)               :: dat(8) !!     real(kind=realtime),intent(out)  :: unixtime !!     integer,intent(out)              :: ierr !! !!##DESCRIPTION !!    Converts a DAT date-time array to a UET (Unix Epoch Time). !! !!##OPTIONS !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!              dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !!##RETURNS !!    unixtime  The \"Unix Epoch\" time, or the number of seconds since !!              00:00:00 on January 1st, 1970, UTC. !!    ierr      Error code. If 0 no error occurred. !! !!##EXAMPLE !! !!     Sample program: !! !!      program demo_date_to_unix !!      use M_time, only : date_to_unix, realtime !!      implicit none !!      integer             :: dat(8) !!      real(kind=realtime) :: unixtime !!      integer             :: ierr !!         call date_and_time(values=dat) !!         write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!         call date_to_unix(dat,unixtime,ierr) !!         write(*,*)'Unix Epoch time is ',unixtime !!         write(*,*)'ierr is ',ierr !!      end program demo_date_to_unix !! !!     results: !! !!      Today is:2016:7:18:-240:23:44:20:434 !!      Unix Epoch time is    1468899860.4340105 !!      ierr is            0 !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine date_to_unix ( dat , unixtime , ierr ) ! ident_4=\"@(#)M_time::date_to_unix(3f): Convert DAT date-time array to Unix Epoch Time\" integer , intent ( in ) :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME real ( kind = realtime ), intent ( out ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: ierr ! return 0 on success, otherwise 1 real ( kind = realtime ) :: julian real ( kind = realtime ), save :: julian_at_epoch logical , save :: first = . true . !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Convert zero of Unix Epoch Time to Julian Date and save call date_to_julian ([ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ], julian_at_epoch , ierr ) if ( ierr . ne . 0 ) return ! Error first = . false . endif !----------------------------------------------------------------------------------------------------------------------------------- call date_to_julian ( dat , julian , ierr ) if ( ierr . ne . 0 ) return ! Error unixtime = ( julian - julian_at_epoch ) * secday end subroutine date_to_unix !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! !> !!##NAME !!    mtprng_init(3f) - [M_random:MERSENNE TWISTER] Initialize the Mersenne Twister random number generator with \"seed\" !!    (LICENSE:CUSTOM OPEN) !! !!##SYNOPSIS !! !!    subroutine mtprng_init(seed, state) !!    integer(INT32),     intent(in)  :: seed !!    type(mtprng_state), intent(out) :: state !! !!##DESCRIPTION !!    Initializes the Mersenne Twister random number generator with \"seed\" !! !!##OPTIONS !!    seed   A seed value is used to start a specific sequence of pseudo-random numbers !!    state  generator state initialized by mtprng_init(3f) or mtprng_init_array(3f) !! !!##EXAMPLE !! !!   Sample program: !! !!    program demo_mtprng_init !!    use M_random, only : mtprng_state, mtprng_init, mtprng_rand64 !!    use, intrinsic :: iso_fortran_env, only : int32, int64 !!    implicit none !!    integer(INT32) :: seed !!    type(mtprng_state) :: state !!       GET_SEED: block !!       integer :: count !!       integer :: count_rate !!          call system_clock(count, count_rate) !!          seed=count !!       endblock GET_SEED !!      call mtprng_init(seed, state) !!      ! returns a INT64 integer with a range in 0 .. 2&#94;32-1 !!      write(*,*) mtprng_rand64(state) !!    end program demo_mtprng_init !! !!   Sample Results: !! !!      867010878 subroutine mtprng_init ( seed , state ) ! ident_5=\"@(#)M_random::mtprng_int(3f): Initializes the Mersenne Twister random number generator with seed\" ! arguments integer ( INT32 ), intent ( in ) :: seed type ( mtprng_state ), intent ( out ) :: state ! working storage integer :: i ! save seed state % mt ( 0 ) = seed ! Set the seed using values suggested by Matsumoto & Nishimura, using !   a generator by Knuth. See original source for details. do i = 1 , N - 1 state % mt ( i ) = iand ( 4294967295_INT64 , 1812433253_INT64 * ieor ( state % mt ( i - 1 ), ishft ( state % mt ( i - 1 ), - 30_INT64 )) + i ) enddo state % mti = N end subroutine mtprng_init !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! !> !!##NAME !!    mtprng_rand64(3f) - [M_random:MERSENNE TWISTER] Obtain the next 64-bit integer in the pseudo-random sequence !!    (LICENSE:CUSTOM OPEN) !! !!##SYNOPSIS !! !!    function mtprng_rand64(state) result(r) !!    type(mtprng_state), intent(inout) :: state !!    integer(INT64) :: r !! !!##DESCRIPTION !!    Obtain the next 64-bit integer in the pseudo-random sequence in the range 0 to 2&#94;32-1. !!    Note that the range is considerably below the value of HUGE(0_int64). !! !!##OPTIONS !!    state  generator state initialized by mtprng_init(3f) or mtprng_init_array(3f) !! !!##RETURNS !!    r      next pseudo-random value in the range 0 to 2&#94;32-1 !! !!##EXAMPLE !! !!   Sample program: !! !!    program demo_mtprng_rand64 !!    use M_random, only : mtprng_state, mtprng_init, mtprng_rand64 !!    use, intrinsic :: iso_fortran_env, only : int32, int64 !!    implicit none !!    integer(INT32) :: seed !!    type(mtprng_state) :: state !!      GET_SEED: block !!      integer :: count !!      integer :: count_rate !!         call system_clock(count, count_rate) !!      seed = count !!      endblock GET_SEED !!      call mtprng_init(seed, state) !!      write(*,*) mtprng_rand64(state) !!    end program demo_mtprng_rand64 function mtprng_rand64 ( state ) result ( r ) ! ident_6=\"@(#)M_random::mtprng_rand64(3f): Obtain the next 64-bit integer in the pseudo-random sequence\" ! arguments type ( mtprng_state ), intent ( inout ) :: state !return type integer ( INT64 ) :: r ! internal constants integer ( INT64 ), dimension ( 0 : 1 ), parameter :: mag01 = ( / 0_INT64 , - 1727483681_INT64 / ) ! Period parameters integer ( INT64 ), parameter :: UPPER_MASK = 2147483648_INT64 integer ( INT64 ), parameter :: LOWER_MASK = 2147483647_INT64 ! Tempering parameters integer ( INT64 ), parameter :: TEMPERING_B = - 1658038656_INT64 integer ( INT64 ), parameter :: TEMPERING_C = - 272236544_INT64 ! Note: variable names match those in original example integer ( INT32 ) :: kk ! Generate N words at a time if ( state % mti >= N ) then ! The value -1 acts as a flag saying that the seed has not been set. if ( state % mti == - 1 ) call mtprng_init ( 4357_INT32 , state ) ! Fill the mt array do kk = 0 , N - M - 1 r = ior ( iand ( state % mt ( kk ), UPPER_MASK ), iand ( state % mt ( kk + 1 ), LOWER_MASK )) state % mt ( kk ) = ieor ( ieor ( state % mt ( kk + M ), ishft ( r , - 1_INT64 )), mag01 ( iand ( r , 1_INT64 ))) enddo do kk = N - M , N - 2 r = ior ( iand ( state % mt ( kk ), UPPER_MASK ), iand ( state % mt ( kk + 1 ), LOWER_MASK )) state % mt ( kk ) = ieor ( ieor ( state % mt ( kk + ( M - N )), ishft ( r , - 1_INT64 )), mag01 ( iand ( r , 1_INT64 ))) enddo r = ior ( iand ( state % mt ( N - 1 ), UPPER_MASK ), iand ( state % mt ( 0 ), LOWER_MASK )) state % mt ( N - 1 ) = ieor ( ieor ( state % mt ( M - 1 ), ishft ( r , - 1 )), mag01 ( iand ( r , 1_INT64 ))) ! Start using the array from first element state % mti = 0 endif ! Here is where we actually calculate the number with a series of !   transformations r = state % mt ( state % mti ) state % mti = state % mti + 1 !------------------------- !!r = ieor(r,ishft(r,-11)) r = ieor ( r , ishft ( iand ( 4294967295_INT64 , r ), - 11 )) ! Added a 32-bit mask to first r shift !------------------------- r = iand ( 4294967295_INT64 , ieor ( r , iand ( ishft ( r , 7 ), TEMPERING_B ))) r = iand ( 4294967295_INT64 , ieor ( r , iand ( ishft ( r , 15 ), TEMPERING_C ))) r = ieor ( r , ishft ( r , - 18 )) end function mtprng_rand64 !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! end module M_uuid !> !! UUID (Universally unique identifier) !! !!    From Wikipedia, the free encyclopedia !! !!    A universally unique identifier (UUID) is a 128-bit number used to !!    identify information in computer systems. !! !!    When generated according to the standard methods, UUIDs are for practical !!    purposes unique, without depending for their uniqueness on a central !!    registration authority or coordination between the parties generating !!    them, unlike most other numbering schemes. While the probability that !!    a UUID will be duplicated is not zero, it is close enough to zero to !!    be negligible. !! !!    Thus, anyone can create a UUID and use it to identify something with near !!    certainty that the identifier does not duplicate one that has already !!    been, or will be, created to identify something else. Information labeled !!    with UUIDs by independent parties can therefore be later combined into !!    a single database, or transmitted on the same channel, without needing !!    to resolve conflicts between identifiers. !! !!    Adoption of UUIDs and GUIDs is widespread, with many computing platforms !!    providing support for generating them, and for parsing their textual !!    representation. !! !!    6   Versions 6.1 Nil UUID !!    6.2 Version 1 (date-time and MAC address) !!    6.3 Version 2 (date-time and MAC address, DCE security version) !!    6.4 Versions 3 and 5 (namespace name-based) !!    6.5 Version 4 (random) !! !!    7 Collisions !!    8 Uses 8.1 In COM !!    8.2 As database keys !! !! Standards !! !!    UUIDs are standardized by the Open Software Foundation (OSF) as part of !!    the Distributed Computing Environment (DCE).[3][4] !! !!    UUIDs are documented as part of ISO/IEC 11578:1996 \"Information technology !!    – Open Systems Interconnection – Remote Procedure Call (RPC)\" and !!    more recently in ITU-T Rec. X.667 | ISO/IEC 9834-8:2005.[5] !! !!    The Internet Engineering Task Force (IETF) published the Standards-Track, !!    RFC 4122,[2] technically equivalent to ITU-T Rec. X.667 | ISO/IEC 9834-8. !! !! Format !! !!    In its canonical textual representation, the sixteen octets of a UUID !!    are represented as 32 hexadecimal (base 16) digits, displayed in five !!    groups separated by hyphens, in the form 8-4-4-4-12 for a total of 36 !!    characters (32 alphanumeric characters and four hyphens). !! !!    For example: !! !!       123e4567-e89b-12d3-a456-426655440000 !!       xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx !! !!    The four bits of digit M indicate the UUID version, and the one to !!    three most significant bits of digit N indicate the UUID variant. In the !!    example, M is 1 and N is a (10xx), meaning that the UUID is a variant 1, !!    version 1 UUID; that is, a time-based DCE/RFC 4122 UUID. !! !!    The canonical 8-4-4-4-12 format string is based on the \"record layout\" !!    for the 16 bytes of the UUID:[2] !! !!    UUID record layout !! !!    Name !! !!    Length (bytes) !! !!    Length (hex digits) !! !!    Contents !! !!       time_low 4 8 integer giving the low 32 bits of the time !!       time_mid 2 4 integer giving the middle 16 bits of the time !!       time_hi_and_version 2 4 4-bit \"version\" in the most significant bits, followed by the high 12 bits of the time !! !!       clock_seq_hi_and_res clock_seq_low 2 4 1-3 bit \"variant\" in the most !!       significant bits, followed by the 13-15 bit clock sequence node 6 12 the 48-bit node id !! !!    These fields correspond to those in version 1 and 2 time-based UUIDs, !!    but the same 8-4-4-4-12 representation is used for all UUIDs, even for !!    UUIDs which are constructed differently. !! !!    RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. A !!    UUID presented as a URN appears as follows:[2] !! !!       urn:uuid:123e4567-e89b-12d3-a456-426655440000 !! !! Encoding !! !!    The binary encoding of UUIDs varies between systems. Many systems encode !!    the UUID entirely in a big-endian format. !! !!    For example, 00112233-4455-6677-8899-aabbccddeeff is encoded as the !!    bytes 00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff. !! !!    Other systems, notably Microsoft's marshalling of UUIDs in their COM/OLE !!    libraries, use a mixed-endian format, whereby the first three components !!    of the UUID are little-endian, and the last two are big-endian. !! !!    For example, !! !!       00112233-4455-6677-8899-aabbccddeeff !! !!    is encoded as the bytes 33 22 11 00 55 44 77 66 88 99 aa bb cc dd ee ff. !! !! Variants !! !!    One of the variants defined by RFC 4122, variant 0 (indicated by the !!    one-bit pattern 0xxx N=0..7), is for backwards compatibility with !!    the circa 1988, now obsolete, Apollo Network Computing System 1.5 !!    UUID format. In this format, the first 6 octets of the UUID are a !!    48-bit timestamp (the number of 4 microsecond units of time since 1 !!    Jan 1980 UTC); the next 2 octets are reserved; the next octet is the !!    \"address family\"; and the final 7 octets are a 56-bit host ID in the !!    form specified by the address family. Though different in detail, the !!    similarity with modern version 1 UUIDs is evident. The variant bits in !!    the current UUID specification coincide with the high bits of the address !!    family octet in NCS UUIDs. Though the address family could hold values in !!    the range 0..255, only the values 0..13 were ever defined. Accordingly, !!    the variant 0 bit pattern 0xxx avoids conflicts with historical NCS UUIDs, !!    should any still exist in databases.[7] !! !!    The 3-bit variant bit pattern 111x N=e..f is reserved for possible !!    future variants.[2] !! !!    The other two variants, variants 1 and 2, are used by the current UUID !!    specifications. Variant 1 UUIDs (10xx N=8..b, 2 bits) are referred to !!    as RFC 4122/DCE 1.1 UUIDs, or \"Leach-Salz\" UUIDs, after the authors !!    of the original Internet Draft. Variant 2 (110x N=c..d, 3 bits) is !!    characterized in the RFC as \"reserved, Microsoft Corporation backward !!    compatibility\", and was used for early GUIDs on the Microsoft Windows !!    platform. Variant bits aside, the two variants are the same except that !!    when reduced to a binary form for storage or transmission, variant 1 !!    UUIDs use \"network\" (big-endian) byte order, while variant 2 GUIDs use !!    \"native\" (little-endian) byte order. In their textual representations, !!    variants 1 and 2 are the same except for the variant bits. !! !!    When byte swapping is required to convert between the big-endian byte !!    order of variant 1 and the little-endian byte order of variant 2, the !!    fields above define the swapping. The first three fields are unsigned !!    32- and 16-bit integers and are subject to swapping, while the last two !!    fields consist of uninterpreted bytes, not subject to swapping. This !!    byte swapping applies even for version 3, 4, and 5 UUID's where the !!    canonical fields do not correspond to the content of the UUID.[2] !! !!    Note that while some important GUIDs, such as the identifier for the !!    Component Object Model IUnknown interface, are nominally variant 2 UUIDs, !!    many identifiers generated and used in Microsoft Windows software !!    and referred to as \"GUIDs\" are standard variant 1 RFC 4122/DCE 1.1 !!    network byte-order UUIDs, rather than little-endian variant 2 UUIDs. The !!    current version of the Microsoft guidgen tool produces standard variant !!    1 UUIDs. Some Microsoft documentation states that \"GUID\" is a synonym !!    for \"UUID\",[8] as standardized in RFC 4122. RFC 4122 itself states that !!    UUIDs \"are also known as GUIDs\". All this suggests that \"GUID\", while !!    originally referring to a variant of UUID used by Microsoft, has become !!    simply an alternative name for UUID, with both variant 1 and variant 2 !!    GUIDs being extant. !! !! Versions !! !!    For both variants 1 and 2, five \"versions\" are defined in the standards, !!    and each version may be more appropriate than the others in specific !!    use cases. Version is indicated by the M in the string representation. !! !!    Version 1 UUIDs are generated from a time and a node id (usually the !!    MAC address); version 2 UUIDs are generated from an identifier (usually !!    a group or user id), time, and a node id; versions 3 and 5 produce !!    deterministic UUIDs generated by hashing a namespace identifier and name; !!    and version 4 UUIDs are generated using a random or pseudo-random number. !! !! Nil UUID !! !!    The \"nil\" UUID, a special case, is the UUID, !! !!       00000000-0000-0000-0000-000000000000; that is, all bits set to zero.[2] !! !! Version 1 (date-time and MAC address)[edit] !! !!    Version 1 concatenates the 48-bit MAC address of the \"node\" (that is, the !!    computer generating the UUID), with a 60-bit timestamp, being the number !!    of 100-nanosecond intervals since midnight 15 October 1582 Coordinated !!    Universal Time (UTC), the date on which the Gregorian calendar was first !!    adopted. RFC 4122 states that the time value rolls over around 3400 AD,[2] !!    depending on the algorithm used, which implies that the 60-bit timestamp !!    is a signed quantity. However some software, such as the libuuid library, !!    treats the timestamp as unsigned, putting the rollover time in 5236 AD.[9] !! !!    A 13- or 14-bit \"uniquifying\" clock sequence extends the timestamp in !!    order to handle cases where the processor clock does not advance fast !!    enough, or where there are multiple processors and UUID generators per !!    node. With each version 1 UUID corresponding to a single point in space !!    (the node) and time (intervals and clock sequence), the chance of two !!    properly-generated version 1 UUID's being unintentionally the same is !!    practically nil. Since the time and clock sequence total 74 bits, 274 !!    (1.8x1022 or 18 sextillion) version 1 UUIDs can be generated per node id, !!    at a maximum average rate of 163 billion per second per node id.[2] !! !!    In contrast to other UUID versions, version 1 and 2 UUIDs based on !!    MAC addresses from network cards rely for their uniqueness in part on !!    an identifier issued by a central registration authority, namely the !!    Organizationally Unique Identifier (OUI) part of the MAC address, which !!    is issued by the IEEE to manufacturers of networking equipment.[10] The !!    uniqueness of version 1 and 2 UUIDs based on network card MAC addresses !!    also depends on network card manufacturers properly assigning unique !!    MAC addresses to their cards, which like other manufacturing processes !!    is subject to error. !! !!    Usage of the node's network card MAC address for the node id means !!    that a version 1 UUID can be tracked back to the computer that created !!    it. Documents can sometimes be traced to the computers where they were !!    created or edited through UUIDs embedded into them by word processing !!    software. This privacy hole was used when locating the creator of the !!    Melissa virus.[11] !! !!    RFC 4122 does allow the MAC address in a version 1 (or 2) UUID to be !!    replaced by a random 48-bit node id, either because the node does not !!    have a MAC address, or because it is not desirable to expose it. In that !!    case, the RFC requires that the least significant bit of the first octet !!    of the node id should be set to 1.[2] This corresponds to the multicast !!    bit in MAC addresses and setting it serves to differentiate UUIDs where !!    the node id is randomly-generated from those based on MAC addresses from !!    network cards, which typically have unicast MAC addresses.[2] !! !! Version 2 (date-time and MAC address, DCE security version)[edit] !! !!    RFC 4122 reserves version 2 for \"DCE security\" UUIDs; but it does not !!    provide any details. For this reason, many UUID implementations omit !!    version 2. However, the specification of version 2 UUIDs is provided by !!    the DCE 1.1 Authentication and Security Services specification.[4] !! !!    Version 2 UUIDs are similar to version 1, except that the least !!    significant 8 bits of the clock sequence are replaced by a \"local domain\" !!    number, and the least significant 32 bits of the timestamp are replaced !!    by an integer identifier meaningful within the specified local domain. On !!    POSIX systems, local domain numbers 0 and 1 are for user ids (UIDs), !!    and group ids (GIDs), respectively, and other local domain numbers !!    are site-defined.[4] On non-POSIX systems, all local domain numbers !!    are site-defined. !! !!    The ability to include a 40-bit domain/identifier in the UUID comes !!    with a tradeoff. On the one hand, 40 bits allow about 1 trillion !!    domain/identifier values per node id. On the other hand, with the !!    clock value truncated to the 28 most significant bits, compared to !!    60 bits in version 1, the clock in a version 2 UUID will \"tick\" only !!    once every 429.49 seconds, a little more than 7 minutes, as opposed !!    to every 100 nanoseconds for version 1. And with a clock sequence of !!    only 6 bits, compared to 14 bits in version 1, only 64 unique UUID's !!    per node/domain/identifier can be generated per 7 minute clock tick, !!    compared to 16,384 clock sequence values for version 1.[12] Thus, !!    Version 2 may not be suitable for cases where UUIDs are required, per !!    node/domain/identifier, at a rate exceeding about 1 per 7 seconds. !! !! Versions 3 and 5 (namespace name-based) !! !!    Version 3 and 5 UUIDs are generated by hashing a namespace identifier !!    and name. Version 3 uses MD5 as the hashing algorithm, and version !!    5 uses SHA1.[2] !! !!    The namespace identifier is itself a UUID. The specification provides !!    UUIDs to represent the namespaces for URLs, fully qualified domain !!    names, object identifiers, and X.500 distinguished names; but any !!    desired UUID may be used as a namespace designator. !! !!    To determine the version 3 UUID corresponding to a given namespace and !!    name, the UUID of the namespace is transformed to a string of bytes, !!    concatenated with the input name, then hashed with MD5, yielding !!    128 bits. Six or seven bits are then replaced by fixed values, the !!    4-bit version (e.g. 0011 for version 3), and the 2- or 3-bit UUID !!    \"variant\" (e.g. 10 indicating a RFC 4122 UUIDs, or 110 indicating !!    a legacy Microsoft GUID). Since 6 or 7 bits are thus predetermined, !!    only 121 or 122 bits contribute to the uniqueness of the UUID. !! !!    Version 5 UUIDs are similar, but SHA1 is used instead of MD5. Since !!    SHA1 generates 160-bit digests, the digest is truncated to 128-bits !!    before the version and variant bits are inserted. !! !!    Version 3 and 5 UUIDs have the property that the same namespace and !!    name will map to the same UUID. However, neither the namespace nor !!    name can be determined from the UUID, given the other, except by !!    brute-force search. !! !!    RFC 4122 recommends version 5 (SHA1) over version 3 (MD5) and counsels !!    against use of UUIDs of either version as security credentials.[2] !! !! Version 4 (random) !! !!    A version 4 UUID is randomly generated. As in other UUIDs, four bits !!    are used to indicate version 4, and 2 or 3 bits to indicate the variant !!    (10 or 110 for variants 1 and 2, respectively). Thus, for variant 1 !!    (that is, most UUIDs) a random version 4 UUID will have 6 predetermined !!    variant and version bits, leaving 122 bits for the randomly-generated !!    part, for a total of 2122, or 5.3x1036 (5.3 undecillion) possible !!    version 4 variant 1 UUIDs. There are half as many possible version 4 !!    variant 2 UUIDs (legacy GUIDs) because there is one less random bit !!    available, 3 bits being consumed for the variant. !! !!    Some pseudorandom number generators lack necessary entropy to produce !!    sufficiently pseudorandom numbers. For example, the WinAPI GUID !!    generator, which uses a pseudorandom number generator, has been shown !!    to produce UUIDs which follow a predictable pattern.[citation needed] !!    RFC 4122 advises that \"distributed applications generating UUIDs at a !!    variety of hosts must be willing to rely on the random number source !!    at all hosts. If this is not feasible, the namespace variant should !!    be used.\" !! !! Collisions !! !!    Collision occurs when the same UUID is generated more than once and !!    assigned to different referents. In the case of standard version 1 !!    and 2 UUIDs using unique MAC addresses from network cards, collisions !!    can occur only when an implementation varies from the standards, !!    either inadvertently or intentionally. !! !!    In contrast with version 1 and 2 UUIDs using randomly-generated node !!    ids, hash-based version 3 and 5 UUIDs, and random version 4 UUIDs, !!    collisions can occur even without implementation problems, albeit !!    with a probability so small that it can normally be ignored. This !!    probability can be computed precisely based on analysis of the !!    birthday problem.[13] !! !!    For example, the number of random version 4 UUIDs which need to be !!    generated in order to have a 50% probability of at least one collision !!    is 2.71 quintillion, computed as follows: !! !!    n ≈ 1 2   + 1 4   + 2 × ln ⁡ ( 2 ) × 2 122     ≈ 2.71 × 10 18     {\\displaystyle n\\approx {\\frac {1}{2}}+{\\sqrt {{\\frac {1}{4}}+2\\times \\ln(2)\\times 2&#94;{122}}}\\approx 2.71\\times 10&#94;{18}}  {\\displaystyle n\\approx {\\frac {1}{2}}+{\\sqrt {{\\frac {1}{4}}+2\\times \\ln(2)\\times 2&#94;{122}}}\\approx 2.71\\times 10&#94;{18}}[14] !! !!    This number is equivalent to generating 1 billion UUIDs per second !!    for about 85 years, and a file containing this many UUIDs, at 16 !!    bytes per UUID, would be about 45 exabytes, many times larger than !!    the largest databases currently in existence, which are on the order !!    of hundreds of petabytes.[15][16] !! !!    The smallest number of version 4 UUIDs which must be generated for !!    the probability of finding a collision to be p is approximated by !!    the formula: !! !!       2 × 2 122   × ln ⁡ 1 1 − p        {\\displaystyle {\\sqrt {2\\times 2&#94;{122}\\times \\ln {\\frac {1}{1-p}}}}}  {\\displaystyle {\\sqrt {2\\times 2&#94;{122}\\times \\ln {\\frac {1}{1-p}}}}} !! !!    Thus, for there to be a one in a billion chance of duplication, !!    103 trillion version 4 UUIDs must be generated. !! !! Uses !! !!    Significant uses include ext2/ext3/ext4 filesystem userspace tools !!    (e2fsprogs uses libuuid provided by util-linux), LUKS encrypted !!    partitions, GNOME, KDE, and Mac OS X,[17] most of which are derived from !!    the original implementation by Theodore Ts'o.[9] !! !!    One of the uses of UUIDs in Solaris (using Open Software Foundation !!    implementation) is identification of a running operating system instance !!    for the purpose of pairing crash dump data with Fault Management Event !!    in the case of kernel panic.[18] !! !! !! As database keys !! !!    UUIDs are commonly used as a unique key in database tables. The !!    NEWID function in Microsoft SQL Server version 4 Transact-SQL returns !!    standard random version 4 UUIDs, while the NEWSEQUENTIALID function !!    returns 128-bit identifiers similar to UUIDs which are committed !!    to ascend in sequence until the next system reboot.[22] The Oracle !!    Database SYS_GUID function does not return a standard GUID, despite !!    the name. Instead, it returns a 16-byte 128-bit RAW value based !!    on a host identifier and a process or thread identifier, somewhat !!    similar to a GUID.[23] PostgreSQL contains a UUID datatype,[24] !!    and can generate most versions of UUIDs through the use of functions !!    from modules.[25][26] MySQL provides a UUID function, which generates !!    standard version 1 UUIDs.[27] !! !!    The random nature of standard version 3, 4, and 5 UUIDs and the !!    ordering of the fields within standard version 1 and 2 UUIDs may !!    create problems with database locality or performance when UUIDs !!    are used as primary keys. For example, in 2002 Jimmy Nilsson !!    reported a significant improvement in performance with Microsoft !!    SQL Server when the version 4 UUIDs being used as keys were modified !!    to include a non-random suffix based on system time. This so-called !!    \"COMB\" (combined time-GUID) approach made the UUIDs non-standard and !!    significantly more likely to be duplicated, as Nilsson acknowledged, !!    but Nilsson only required uniqueness within the application.[28]","tags":"","loc":"sourcefile/m_uuid.f90.html"},{"title":"unique.f90 – M_uuid","text":"Contents Programs unique Source Code unique.f90 Source Code program unique ! this is a utility program. It is typically built using ccall(1). use M_CLI2 , only : set_args , lget , sgets , iget , unnamed use M_uuid , only : generate_uuid use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit implicit none integer :: version integer :: repeat integer :: i , j character ( len = 10 ), allocatable :: methods (:) character ( len = :), allocatable :: prefix character ( len = :), allocatable :: help_text (:) character ( len = :), allocatable :: version_text (:) ! define arguments, default values and crack command line call setup () call set_args ( '--method:m \"4\" --urn:U F --repeat:r 1' , help_text , version_text ) methods = [ character ( len = 10 ) :: sgets ( 'method' ), unnamed ] ! get value of command line argument -method or unnamed strings if ( size ( methods ). eq . 0 ) methods = [ \"4\" ] repeat = iget ( 'repeat' ) ! get value of command line argument -repeat prefix = merge ( 'urn:uuid:' , '         ' , lget ( 'urn' )) ! get value of command line argument -urn prefix = trim ( prefix ) do i = 1 , size ( methods ) select case ( methods ( i )) case ( '0' , 'nil' ); version = 0 case ( '1' , 'time' ); version = 1 case ( '' , '4' , 'random' ); version = 4 case default ; version = 4 write ( stderr , '(*(g0,1x))' ) '*unique* unknown method' , methods stop 1 endselect do j = 1 , repeat write ( * , '(2a)' ) prefix , generate_uuid ( version ) enddo enddo contains subroutine setup () ! @(#)help_usage(3f): sets help information version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>       ' ,& '@(#)PROGRAM:        unique(1)>                                                  ' ,& '@(#)DESCRIPTION:    output a UUID (Universally Unique ID)>                      ' ,& '@(#)VERSION:        1.0, 20180427>                                              ' ,& '@(#)AUTHOR:         John S. Urban>                                              ' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>             ' ,& '@(#)COMPILED:       Tue, Feb 9th, 2021 9:19:16 PM>                              ' ,& '' ] help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '    unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string         ' ,& '                  per RFC 4122                                                  ' ,& '    (LICENSE:PD)                                                                ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '    unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version]           ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   unique(3f) generates UUID strings according to the RFC 4122                  ' ,& '   standard.                                                                    ' ,& '                                                                                ' ,& '   A universally unique identifier (UUID) is a 128-bit number used to           ' ,& '   identify information in computer systems. When generated according           ' ,& '   to standard methods UUIDs are for practical purposes unique.                 ' ,& '                                                                                ' ,& '   Standard methods 0,1, and 4 are supported as described in RFC 4122.          ' ,& '                                                                                ' ,& '   UUID strings are particularly useful as keys for relational database         ' ,& '   entries, and for building unique temporary file names (especially in         ' ,& '   cross-mounted filesystems that more than one OS is utilizing).               ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '    --method NAME  Select the UUID version type. Supported methods are          ' ,& '                   nil|0, random|4, time|1.                                     ' ,& '                                                                                ' ,& '                   0. Nil UUID (ie. ''''00000000-0000-0000-0000-000000000000'''')' ,& '                   1. time-based UUID                                           ' ,& '                   2. Not implemented                                           ' ,& '                   3. Not implemented                                           ' ,& '                   4. pseudo-RNG(Random Number Generator) based                 ' ,& '                   5. Not implemented                                           ' ,& '                                                                                ' ,& '    --urn       RFC 4122 defines a Uniform Resource Name (URN)                  ' ,& '                namespace for UUIDs. IE., the output is                         ' ,& '                prefixed with \"urn:uuid:\".                                      ' ,& '                                                                                ' ,& '    --repeat N  Number of UUID strings to generate                              ' ,& '                                                                                ' ,& '    --help      display this help and exit                                      ' ,& '                                                                                ' ,& '    --version   output version information and exit                             ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '  Sample commands                                                               ' ,& '                                                                                ' ,& '   unique                                                                       ' ,& '   4bb8051e-4af3-11e8-6603-4254ffee9a14                                         ' ,& '                                                                                ' ,& '   unique -urn                                                                  ' ,& '   urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a                                ' ,& '                                                                                ' ,& '   unique -method time -repeat 4                                                ' ,& '   f2a2faf0-833a-11e9-7373-5eb4cfd7e237                                         ' ,& '   f2a2faf0-833a-11e9-7373-afbb9f7b9100                                         ' ,& '   f2a2faf0-833a-11e9-7373-cde3ffff3681                                         ' ,& '   f2a2faf0-833a-11e9-7373-271cfbfd42bc                                         ' ,& '                                                                                ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] !> !!##NAME !!     unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string !!                   per RFC 4122 !!     (LICENSE:PD) !! !!##SYNOPSIS !! !!     unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version] !! !!##DESCRIPTION !!    unique(3f) generates UUID strings according to the RFC 4122 !!    standard. !! !!    A universally unique identifier (UUID) is a 128-bit number used to !!    identify information in computer systems. When generated according !!    to standard methods UUIDs are for practical purposes unique. !! !!    Standard methods 0,1, and 4 are supported as described in RFC 4122. !! !!    UUID strings are particularly useful as keys for relational database !!    entries, and for building unique temporary file names (especially in !!    cross-mounted filesystems that more than one OS is utilizing). !! !!##OPTIONS !!     --method NAME  Select the UUID version type. Supported methods are !!                    nil|0, random|4, time|1. !! !!                    0. Nil UUID (ie. ''00000000-0000-0000-0000-000000000000'') !!                    1. time-based UUID !!                    2. Not implemented !!                    3. Not implemented !!                    4. pseudo-RNG(Random Number Generator) based !!                    5. Not implemented !! !!     --urn       RFC 4122 defines a Uniform Resource Name (URN) !!                 namespace for UUIDs. IE., the output is !!                 prefixed with \"urn:uuid:\". !! !!     --repeat N  Number of UUID strings to generate !! !!     --help      display this help and exit !! !!     --version   output version information and exit !! !!##EXAMPLES !! !!   Sample commands !! !!    unique !!    4bb8051e-4af3-11e8-6603-4254ffee9a14 !! !!    unique -urn !!    urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a !! !!    unique -method time -repeat 4 !!    f2a2faf0-833a-11e9-7373-5eb4cfd7e237 !!    f2a2faf0-833a-11e9-7373-afbb9f7b9100 !!    f2a2faf0-833a-11e9-7373-cde3ffff3681 !!    f2a2faf0-833a-11e9-7373-271cfbfd42bc !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain end subroutine setup end program unique","tags":"","loc":"sourcefile/unique.f90.html"},{"title":"demo_generate_uuid.f90 – M_uuid","text":"Contents Programs demo_generate_uuid Source Code demo_generate_uuid.f90 Source Code program demo_generate_uuid use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid ! uuid = generate_uuid ( 1 ) ! version 1 (time-based UUID) write ( * , '(a36)' ) uuid ! uuid = generate_uuid ( 4 ) ! version 4 (pseudo-RNG-based), default ! ! RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. write ( * , '(\"urn:uuid:\",a36)' ) uuid ! ! a good scratch file name open ( file = '/tmp/scratch_' // uuid , unit = 10 ) ! end program demo_generate_uuid","tags":"","loc":"sourcefile/demo_generate_uuid.f90.html"},{"title":"test_suite_M_uuid.f90 – M_uuid","text":"Contents Programs runtest Modules M_test_suite_M_uuid Source Code test_suite_M_uuid.f90 Source Code module M_test_suite_M_uuid use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level use M_uuid , only : generate_uuid private public test_suite_m_uuid contains subroutine test_suite_m_uuid () ! this should contains tests for all public procedures in the module call test_generate_uuid () end subroutine test_suite_m_uuid !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! subroutine test_generate_uuid () use M_verify , only : unit_check , unit_check_start , unit_check_good , unit_check_bad , unit_check_done !   This just checks that we can generate the various types of UUID !   (without crashing) and checks that they have the correct syntax. We !   could also check that the UUID changes for each call and I think there !   is an additional check we could make within the UUID itself. But for !   now this is enough. character ( len = 36 ) :: uuid call unit_check_start ( 'generate_uuid' ) ! start tests uuid = generate_uuid ( 0 ) call unit_check ( 'generate_uuid' , check_uuid ( uuid ). and .( uuid == '00000000-0000-0000-0000-000000000000' ), msg = 'Version 0 ' // uuid ) uuid = generate_uuid ( 1 ) call unit_check ( 'generate_uuid' , check_uuid ( uuid ), msg = 'Version 1 ' // uuid ) uuid = generate_uuid ( 2 ) call unit_check ( 'generate_uuid' , uuid == '' , msg = 'Version 2 (NOT IMPLEMENTED)' ) uuid = generate_uuid ( 3 ) call unit_check ( 'generate_uuid' , uuid == '' , msg = 'Version 3 (NOT IMPLEMENTED)' ) uuid = generate_uuid ( 4 ) call unit_check ( 'generate_uuid' , check_uuid ( uuid ), msg = 'Version 4 ' // uuid ) uuid = generate_uuid ( 5 ) call unit_check ( 'generate_uuid' , uuid == '' , msg = 'Version 5 (NOT IMPLEMENTED)' ) call unit_check ( 'compare' , exercise ( 1000000 ), msg = 'test for duplicates in 1000000 values' ) call unit_check_done ( 'generate_uuid' ) !==================================================================================================================================! contains !==================================================================================================================================! function check_uuid ( chars ) result ( lout ) ! Return true if the string is permitted by the UUID BFN in RFC character ( len =* ) :: chars character ( len = 22 ), parameter :: hex = '0123456789abcdefABCDEF' logical :: lout lout = ( len_trim ( chars ) == 36 ) if ( lout ) then lout = lout . and .( verify ( chars ( 1 : 8 ), hex ) == 0 ) lout = lout . and .( verify ( chars ( 9 : 9 ), '-' ) == 0 ) lout = lout . and .( verify ( chars ( 10 : 13 ), hex ) == 0 ) lout = lout . and .( verify ( chars ( 14 : 14 ), '-' ) == 0 ) lout = lout . and .( verify ( chars ( 15 : 18 ), hex ) == 0 ) lout = lout . and .( verify ( chars ( 19 : 19 ), '-' ) == 0 ) lout = lout . and .( verify ( chars ( 20 : 23 ), hex ) == 0 ) lout = lout . and .( verify ( chars ( 24 : 24 ), '-' ) == 0 ) lout = lout . and .( verify ( chars ( 25 : 36 ), hex ) == 0 ) endif end function check_uuid !==================================================================================================================================! end subroutine test_generate_uuid !==================================================================================================================================! function exercise ( sz ) logical :: exercise integer :: sz character ( len = 36 ), allocatable :: uuid (:) integer :: i , j exercise = . true . TYPES : do j = 1 , 4 , 3 if ( allocated ( uuid )) deallocate ( uuid ) allocate ( uuid ( sz )) do i = 1 , sz uuid ( i ) = generate_uuid ( j ) enddo call sort_shell_strings_lh ( uuid ) call unique_strings ( uuid , icount ) if ( icount . ne . size ( uuid )) then exercise = . false . exit TYPES endif enddo TYPES end function exercise !==================================================================================================================================! subroutine sort_shell_strings_lh ( lines ) ! ident_5=\"@(#)M_sort::sort_shell_strings_lh(3fp):sort strings(a-z) over specified field using shell sort\" character ( len =* ) :: lines (:) character ( len = :), allocatable :: ihold integer :: n , igap , i , j , k , jg n = size ( lines ) if ( n . gt . 0 ) then allocate ( character ( len = len ( lines ( 1 ))) :: ihold ) else ihold = '' endif igap = n INFINITE : do igap = igap / 2 if ( igap . eq . 0 ) exit INFINITE k = n - igap i = 1 INNER : do j = i INSIDE : do jg = j + igap if ( lle ( lines ( j ), lines ( jg ))) exit INSIDE ihold = lines ( j ) lines ( j ) = lines ( jg ) lines ( jg ) = ihold j = j - igap if ( j . lt . 1 ) exit INSIDE enddo INSIDE i = i + 1 if ( i . gt . k ) exit INNER enddo INNER enddo INFINITE end subroutine sort_shell_strings_lh subroutine unique_strings ( array , ivals ) character ( len =* ), intent ( inout ), allocatable :: array (:) integer , intent ( out ) :: ivals integer :: i , isize isize = size ( array ) if ( isize . ge . 2 ) then ivals = 1 do i = 2 , isize if ( array ( i ). ne . array ( i - 1 )) then ivals = ivals + 1 else write ( * , * ) '<ERROR> at ' , i , ' and ' , i + 1 , ' duplicates ' , array ( i ) endif enddo else ivals = isize endif end subroutine unique_strings !==================================================================================================================================! end module M_test_suite_M_uuid !==================================================================================================================================! program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level , unit_check_stop use M_test_suite_M_uuid implicit none unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_uuid () call unit_check_stop () end program runtest !==================================================================================================================================!","tags":"","loc":"sourcefile/test_suite_m_uuid.f90.html"},{"title":"mtprng_state – M_uuid ","text":"type, public :: mtprng_state Contents Variables mt mti Components Type Visibility Attributes Name Initial integer(kind=INT64), public, dimension(0:N-1) :: mt integer(kind=INT32), public :: mti = -1","tags":"","loc":"type/mtprng_state.html"},{"title":"generate_uuid – M_uuid","text":"public function generate_uuid(version) result(uuid) ! generate_uuid(3f) was originally derived from the xmlf90 codebase, (c) Alberto Garcia & Jon Wakelin, 2003-2004.\n ! It also calls RNG routines from Scott Ladd scott.ladd@coyotegulch.com , and the libFoX modules. Although\n ! some sections have been replaced, generate_uuid(3f) was originally based on the libFoX version, with\n ! licensing as follows:\n !\n ! (c) 2005-2009 Toby White tow@uszla.me.uk ! (c) 2007-2009 Gen-Tao Chiang gtc25@cam.ac.uk ! (c) 2008-2012 Andrew Walker a.walker@ucl.ac.uk !\n ! All rights reserved.\n !\n ! * Redistribution and use in source and binary forms, with or without\n ! modification, are permitted provided that the following conditions are\n ! met:\n !\n ! * Redistributions of source code must retain the above copyright notice,\n ! this list of conditions and the following disclaimer.\n !\n ! * Redistributions in binary form must reproduce the above copyright\n ! notice, this list of conditions and the following disclaimer in the\n ! documentation and/or other materials provided with the distribution.\n !\n ! * Neither the name of the copyright holder nor the names of its\n ! contributors may be used to endorse or promote products derived from\n ! this software without specific prior written permission.\n !\n !\n ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n ! “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n ! A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n ! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n ! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n ! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. NAME generate_uuid ( 3 f ) - [ M_uuid ] generate a UUID ( Universally Unique IDentifier ) string per RFC 4122 ( LICENSE : CUSTOM OPEN ) SYNOPSIS function generate_uuid(version) result ( uuid ) integer , intent ( in ), optional :: version character ( len = 36 ) :: uuid DESCRIPTION A universally unique identifier ( UUID ) is a 128 - bit number used to identify information in computer systems . When generated according to standard methods UUIDs are for practical purposes unique . generate_uuid ( 3 f ) converts the UUID to a standard string format per RFC 4122 . AUTHORS based on previous work from Alberto Garcia & Jon Wakelin , 2003 - 2004. RNG routines from Scott Ladd < scott . ladd @coyotegulch . com > , and the libFoX library ( Toby White < tow @uszla . me . uk > , Gen - Tao Chiang < gtc25 @cam . ac . uk > , Andrew Walker < a . walker @ucl . ac . uk > ). OPTIONS version Indicates which standard method as described in RFC 4122 is used to generate the string . Versions 0 , 1 , and 4 are supported . 0 . Nil UUID ( ie . ' 00000000-0000-0000-0000-000000000000 ' ) 1 . time - based UUID 2 . Not implemented 3 . Not implemented 4 . pseudo - RNG ( Random Number Generator ) based 5 . Not implemented EXAMPLE Sample usage: program demo_generate_uuid use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid ! uuid = generate_uuid ( 1 ) ! version 1 ( time - based UUID ) write ( * , ' (a36) ' ) uuid ! uuid = generate_uuid ( 4 ) ! version 4 ( pseudo - RNG - based ) , default ! ! RFC 4122 defines a Uniform Resource Name ( URN ) namespace for UUIDs . write ( * , ' (\"urn:uuid:\",a36) ' ) uuid ! ! a good scratch file name open ( file = ' /tmp/scratch_ ' // uuid , unit = 10 ) ! end program demo_generate_uuid Typical output: e769adf4-4af7-11e8-7421-3c9dfbfe9aab\n urn:uuid:5b0946b8-0eb4-4966-619d-047b7f7e2056 Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: version Return Value character(len=36) Contents Source Code generate_uuid Source Code function generate_uuid ( version ) result ( uuid ) ! ident_2=\"@(#)M_uuid::generate_uuid(3f): generate(approximately) a UUID (Universally Unique IDentifier) string per RFC 4122\" integer , intent ( in ), optional :: version character ( len = 36 ) :: uuid integer ( kind = i8b ) :: timestamp , node integer ( kind = i4b ) :: clock_sequence integer ( kind = i4b ) :: time_low , time_mid , time_hi_and_version integer ( kind = i4b ) :: clk_seq_hi_res , clk_seq_low integer :: values ( 8 ) ! must be default for date_and_time integer ( kind = i4b ) :: variant , v if (. not . initialized ) then ! Use the current date and time to init mtprng but this gives limited variability, so mix the result up. ! Can we do better? In any case, this gets passed through a quick generator inside mtprng_init. call date_and_time ( values = values ) values ( 7 ) = values ( 7 ) * 1000 + values ( 5 ) * 100 + values ( 3 ) * 10 + values ( 1 ) values ( 8 ) = values ( 2 ) * 1000 + values ( 4 ) * 100 + values ( 6 ) * 10 + values ( 8 ) call mtprng_init ( int ( values ( 7 ) * 10000 + values ( 8 ), i4b ), rng_state ) clock_seq = int ( mtprng_rand64 ( rng_state ), i4b ) initialized = . true . endif variant = 1 if ( present ( version )) then v = version else v = 4 endif select case ( v ) case ( 0 ) uuid = '00000000-0000-0000-0000-000000000000' ! Nil UUID return case ( 1 ) !  version 1(time-based) call date_and_time ( values = values ) ! In case of too-frequent requests, we will replace time_low with the count below ... if ( all ( values == values_save )) then hires_count = hires_count + 1 else hires_count = 0 endif timestamp = get_utc_since_1582 ( values ) clock_sequence = clock_seq ! clock sequence (14 bits) node = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 16 )) ! node ( 48 bits) ! No MAC address accessible - see section 4.5 !FIXME case ( 2 - 3 , 5 ) ! Unimplemented uuid = '' return case ( 4 ) ! version 4 (pseudo-RNG-based) timestamp = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 28 )) clock_sequence = int ( mtprng_rand64 ( rng_state ), i4b ) ! clock sequence (14 bits) node = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 16 )) ! node ( 48 bits) case default ! Unspecified uuid = '' return end select time_low = ibits ( timestamp , 0 , 32 ) time_mid = ibits ( timestamp , 32 , 16 ) if ( hires_count == 0 ) then time_hi_and_version = ior ( int ( ibits ( timestamp , 48 , 12 ), i4b ), ishft ( v , 12 )) else time_hi_and_version = ior ( hires_count , ishft ( v , 12 )) endif clk_seq_low = ibits ( clock_sequence , 0 , 8 ) clk_seq_hi_res = ior ( ibits ( clock_sequence , 8 , 6 ), ishft ( variant , 6 )) uuid = int32ToHexOctets ( time_low , 4 ) // \"-\" // & int32ToHexOctets ( time_mid , 2 ) // \"-\" // & int32ToHexOctets ( time_hi_and_version , 2 ) // \"-\" // & int32ToHexOctets ( clk_seq_hi_res , 1 ) // & int32ToHexOctets ( clk_seq_low , 1 ) // \"-\" // & int64ToHexOctets ( node , 6 ) contains !==================================================================================================================================! function int32ToHexOctets ( b , n ) result ( s ) integer ( i4b ), intent ( in ) :: b integer , intent ( in ) :: n ! number of octets to print character ( len = 2 * n ) :: s character , parameter :: hexdigits ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] integer :: i do i = 0 , 2 * n - 1 s ( 2 * n - i : 2 * n - i ) = hexdigits ( ibits ( b , i * 4 , 4 )) enddo end function int32ToHexOctets !==================================================================================================================================! function int64ToHexOctets ( b , n ) result ( s ) integer ( i8b ), intent ( in ) :: b integer , intent ( in ) :: n ! number of octets to print character ( len = 2 * n ) :: s character , parameter :: hexdigits ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] integer :: i do i = 0 , 2 * n - 1 s ( 2 * n - i : 2 * n - i ) = hexdigits ( ibits ( b , i * 4 , 4 )) enddo end function int64ToHexOctets !==================================================================================================================================! end function generate_uuid","tags":"","loc":"proc/generate_uuid.html"},{"title":"setup – M_uuid","text":"subroutine setup() Arguments None Contents Source Code setup Source Code subroutine setup () ! @(#)help_usage(3f): sets help information version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>       ' ,& '@(#)PROGRAM:        unique(1)>                                                  ' ,& '@(#)DESCRIPTION:    output a UUID (Universally Unique ID)>                      ' ,& '@(#)VERSION:        1.0, 20180427>                                              ' ,& '@(#)AUTHOR:         John S. Urban>                                              ' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>             ' ,& '@(#)COMPILED:       Tue, Feb 9th, 2021 9:19:16 PM>                              ' ,& '' ] help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '    unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string         ' ,& '                  per RFC 4122                                                  ' ,& '    (LICENSE:PD)                                                                ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '    unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version]           ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   unique(3f) generates UUID strings according to the RFC 4122                  ' ,& '   standard.                                                                    ' ,& '                                                                                ' ,& '   A universally unique identifier (UUID) is a 128-bit number used to           ' ,& '   identify information in computer systems. When generated according           ' ,& '   to standard methods UUIDs are for practical purposes unique.                 ' ,& '                                                                                ' ,& '   Standard methods 0,1, and 4 are supported as described in RFC 4122.          ' ,& '                                                                                ' ,& '   UUID strings are particularly useful as keys for relational database         ' ,& '   entries, and for building unique temporary file names (especially in         ' ,& '   cross-mounted filesystems that more than one OS is utilizing).               ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '    --method NAME  Select the UUID version type. Supported methods are          ' ,& '                   nil|0, random|4, time|1.                                     ' ,& '                                                                                ' ,& '                   0. Nil UUID (ie. ''''00000000-0000-0000-0000-000000000000'''')' ,& '                   1. time-based UUID                                           ' ,& '                   2. Not implemented                                           ' ,& '                   3. Not implemented                                           ' ,& '                   4. pseudo-RNG(Random Number Generator) based                 ' ,& '                   5. Not implemented                                           ' ,& '                                                                                ' ,& '    --urn       RFC 4122 defines a Uniform Resource Name (URN)                  ' ,& '                namespace for UUIDs. IE., the output is                         ' ,& '                prefixed with \"urn:uuid:\".                                      ' ,& '                                                                                ' ,& '    --repeat N  Number of UUID strings to generate                              ' ,& '                                                                                ' ,& '    --help      display this help and exit                                      ' ,& '                                                                                ' ,& '    --version   output version information and exit                             ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '  Sample commands                                                               ' ,& '                                                                                ' ,& '   unique                                                                       ' ,& '   4bb8051e-4af3-11e8-6603-4254ffee9a14                                         ' ,& '                                                                                ' ,& '   unique -urn                                                                  ' ,& '   urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a                                ' ,& '                                                                                ' ,& '   unique -method time -repeat 4                                                ' ,& '   f2a2faf0-833a-11e9-7373-5eb4cfd7e237                                         ' ,& '   f2a2faf0-833a-11e9-7373-afbb9f7b9100                                         ' ,& '   f2a2faf0-833a-11e9-7373-cde3ffff3681                                         ' ,& '   f2a2faf0-833a-11e9-7373-271cfbfd42bc                                         ' ,& '                                                                                ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] !> !!##NAME !!     unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string !!                   per RFC 4122 !!     (LICENSE:PD) !! !!##SYNOPSIS !! !!     unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version] !! !!##DESCRIPTION !!    unique(3f) generates UUID strings according to the RFC 4122 !!    standard. !! !!    A universally unique identifier (UUID) is a 128-bit number used to !!    identify information in computer systems. When generated according !!    to standard methods UUIDs are for practical purposes unique. !! !!    Standard methods 0,1, and 4 are supported as described in RFC 4122. !! !!    UUID strings are particularly useful as keys for relational database !!    entries, and for building unique temporary file names (especially in !!    cross-mounted filesystems that more than one OS is utilizing). !! !!##OPTIONS !!     --method NAME  Select the UUID version type. Supported methods are !!                    nil|0, random|4, time|1. !! !!                    0. Nil UUID (ie. ''00000000-0000-0000-0000-000000000000'') !!                    1. time-based UUID !!                    2. Not implemented !!                    3. Not implemented !!                    4. pseudo-RNG(Random Number Generator) based !!                    5. Not implemented !! !!     --urn       RFC 4122 defines a Uniform Resource Name (URN) !!                 namespace for UUIDs. IE., the output is !!                 prefixed with \"urn:uuid:\". !! !!     --repeat N  Number of UUID strings to generate !! !!     --help      display this help and exit !! !!     --version   output version information and exit !! !!##EXAMPLES !! !!   Sample commands !! !!    unique !!    4bb8051e-4af3-11e8-6603-4254ffee9a14 !! !!    unique -urn !!    urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a !! !!    unique -method time -repeat 4 !!    f2a2faf0-833a-11e9-7373-5eb4cfd7e237 !!    f2a2faf0-833a-11e9-7373-afbb9f7b9100 !!    f2a2faf0-833a-11e9-7373-cde3ffff3681 !!    f2a2faf0-833a-11e9-7373-271cfbfd42bc !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain end subroutine setup","tags":"","loc":"proc/setup.html"},{"title":"test_suite_m_uuid – M_uuid","text":"public subroutine test_suite_m_uuid() Arguments None Contents Source Code test_suite_m_uuid Source Code subroutine test_suite_m_uuid () ! this should contains tests for all public procedures in the module call test_generate_uuid () end subroutine test_suite_m_uuid","tags":"","loc":"proc/test_suite_m_uuid.html"},{"title":"M_uuid – M_uuid","text":"NAME M_uuid ( 3 f ) - [ M_uuid ] a module of UUID ( Universally Unique IDentifier ) procedures ( LICENSE : CUSTOM OPEN ) SYNOPSIS use m_uuid, only : generate_uuid QUOTE Remember you are unique , just like everyone else . DESCRIPTION A universally unique identifier ( UUID ) is a 128 - bit number used to identify information in computer systems . When generated according to the standard methods , UUIDs are for practical purposes unique , without depending for their uniqueness on a central registration authority or coordination between the parties generating them , unlike most other numbering schemes . While the probability that a UUID will be duplicated is not zero , it is close enough to zero to be negligible . Thus , anyone can create a UUID and use it to identify something with near certainty that the identifier does not duplicate one that has already been or will be created to identify something else . Information labeled with UUIDs by independent parties can therefore be later combined into a single database , or transmitted on the same channel , without needing to resolve conflicts between identifiers . Adoption of UUIDs and GUIDs is widespread . Many computing platforms provide support for generating them , and for parsing their textual representation . RFC 4122 defines a Uniform Resource Name ( URN ) namespace for UUIDs . A UUID presented as a URN appears as follows: urn:uuid: 123e4567 - e89b - 12 d3 - a456 - 426655440000 – Wikipedia PROCEDURES generate_uuid(version)   generate 36-character UUID string provide for routines extracted from other modules (M_time and M_random) Uses iso_fortran_env Contents Variables IEEE32 IEEE64 M N realtime Derived Types mtprng_state Functions generate_uuid Variables Type Visibility Attributes Name Initial integer, public, parameter :: IEEE32 = selected_real_kind(6, 37) integer, public, parameter :: IEEE64 = selected_real_kind(15, 307) integer(kind=INT32), public, parameter :: M = 397_INT32 integer(kind=INT32), public, parameter :: N = 624_INT32 integer, public, parameter :: realtime = kind(0.0d0) Derived Types type, public :: mtprng_state Components Type Visibility Attributes Name Initial integer(kind=INT64), public, dimension(0:N-1) :: mt integer(kind=INT32), public :: mti = -1 Functions public function generate_uuid (version) result(uuid) ! generate_uuid(3f) was originally derived from the xmlf90 codebase, (c) Alberto Garcia & Jon Wakelin, 2003-2004.\n ! It also calls RNG routines from Scott Ladd scott.ladd@coyotegulch.com , and the libFoX modules. Although\n ! some sections have been replaced, generate_uuid(3f) was originally based on the libFoX version, with\n ! licensing as follows:\n !\n ! (c) 2005-2009 Toby White tow@uszla.me.uk ! (c) 2007-2009 Gen-Tao Chiang gtc25@cam.ac.uk ! (c) 2008-2012 Andrew Walker a.walker@ucl.ac.uk !\n ! All rights reserved.\n !\n ! * Redistribution and use in source and binary forms, with or without\n ! modification, are permitted provided that the following conditions are\n ! met:\n !\n ! * Redistributions of source code must retain the above copyright notice,\n ! this list of conditions and the following disclaimer.\n !\n ! * Redistributions in binary form must reproduce the above copyright\n ! notice, this list of conditions and the following disclaimer in the\n ! documentation and/or other materials provided with the distribution.\n !\n ! * Neither the name of the copyright holder nor the names of its\n ! contributors may be used to endorse or promote products derived from\n ! this software without specific prior written permission.\n !\n !\n ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n ! “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n ! A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n ! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n ! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n ! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: version Return Value character(len=36)","tags":"","loc":"module/m_uuid.html"},{"title":"M_test_suite_M_uuid – M_uuid","text":"Uses M_verify M_msg M_uuid Contents Subroutines test_suite_m_uuid Subroutines public subroutine test_suite_m_uuid () Arguments None","tags":"","loc":"module/m_test_suite_m_uuid.html"},{"title":"unique – M_uuid","text":"Uses M_uuid iso_fortran_env M_CLI2 NAME unique ( 1 f ) - [ FUNIX ] generate a UUID ( Universally Unique ID ) string per RFC 4122 ( LICENSE : PD ) SYNOPSIS unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version] DESCRIPTION unique ( 3 f ) generates UUID strings according to the RFC 4122 standard . A universally unique identifier ( UUID ) is a 128 - bit number used to identify information in computer systems . When generated according to standard methods UUIDs are for practical purposes unique . Standard methods 0 , 1 , and 4 are supported as described in RFC 4122 . UUID strings are particularly useful as keys for relational database entries , and for building unique temporary file names ( especially in cross - mounted filesystems that more than one OS is utilizing ) . OPTIONS -- method NAME Select the UUID version type . Supported methods are nil | 0 , random | 4 , time | 1 . 0 . Nil UUID ( ie . '' 00000000 - 0000 - 0000 - 0000 - 000000000000 '' ) 1 . time - based UUID 2 . Not implemented 3 . Not implemented 4 . pseudo - RNG ( Random Number Generator ) based 5 . Not implemented -- urn RFC 4122 defines a Uniform Resource Name ( URN ) namespace for UUIDs . IE ., the output is prefixed with \" urn:uuid: \" . -- repeat N Number of UUID strings to generate -- help display this help and exit -- version output version information and exit EXAMPLES Sample commands unique\n4bb8051e-4af3-11e8-6603-4254ffee9a14\n\nunique -urn\nurn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a\n\nunique -method time -repeat 4\nf2a2faf0-833a-11e9-7373-5eb4cfd7e237\nf2a2faf0-833a-11e9-7373-afbb9f7b9100\nf2a2faf0-833a-11e9-7373-cde3ffff3681\nf2a2faf0-833a-11e9-7373-271cfbfd42bc AUTHOR John S. Urban LICENSE Public Domain Contents Variables help_text i j methods prefix repeat version version_text Subroutines setup Source Code unique Variables Type Attributes Name Initial character(len=:), allocatable :: help_text (:) integer :: i integer :: j character(len=10), allocatable :: methods (:) character(len=:), allocatable :: prefix integer :: repeat integer :: version character(len=:), allocatable :: version_text (:) Subroutines subroutine setup () Arguments None Source Code program unique ! this is a utility program. It is typically built using ccall(1). use M_CLI2 , only : set_args , lget , sgets , iget , unnamed use M_uuid , only : generate_uuid use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit implicit none integer :: version integer :: repeat integer :: i , j character ( len = 10 ), allocatable :: methods (:) character ( len = :), allocatable :: prefix character ( len = :), allocatable :: help_text (:) character ( len = :), allocatable :: version_text (:) ! define arguments, default values and crack command line call setup () call set_args ( '--method:m \"4\" --urn:U F --repeat:r 1' , help_text , version_text ) methods = [ character ( len = 10 ) :: sgets ( 'method' ), unnamed ] ! get value of command line argument -method or unnamed strings if ( size ( methods ). eq . 0 ) methods = [ \"4\" ] repeat = iget ( 'repeat' ) ! get value of command line argument -repeat prefix = merge ( 'urn:uuid:' , '         ' , lget ( 'urn' )) ! get value of command line argument -urn prefix = trim ( prefix ) do i = 1 , size ( methods ) select case ( methods ( i )) case ( '0' , 'nil' ); version = 0 case ( '1' , 'time' ); version = 1 case ( '' , '4' , 'random' ); version = 4 case default ; version = 4 write ( stderr , '(*(g0,1x))' ) '*unique* unknown method' , methods stop 1 endselect do j = 1 , repeat write ( * , '(2a)' ) prefix , generate_uuid ( version ) enddo enddo contains subroutine setup () ! @(#)help_usage(3f): sets help information version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>       ' ,& '@(#)PROGRAM:        unique(1)>                                                  ' ,& '@(#)DESCRIPTION:    output a UUID (Universally Unique ID)>                      ' ,& '@(#)VERSION:        1.0, 20180427>                                              ' ,& '@(#)AUTHOR:         John S. Urban>                                              ' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>             ' ,& '@(#)COMPILED:       Tue, Feb 9th, 2021 9:19:16 PM>                              ' ,& '' ] help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '    unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string         ' ,& '                  per RFC 4122                                                  ' ,& '    (LICENSE:PD)                                                                ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '    unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version]           ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   unique(3f) generates UUID strings according to the RFC 4122                  ' ,& '   standard.                                                                    ' ,& '                                                                                ' ,& '   A universally unique identifier (UUID) is a 128-bit number used to           ' ,& '   identify information in computer systems. When generated according           ' ,& '   to standard methods UUIDs are for practical purposes unique.                 ' ,& '                                                                                ' ,& '   Standard methods 0,1, and 4 are supported as described in RFC 4122.          ' ,& '                                                                                ' ,& '   UUID strings are particularly useful as keys for relational database         ' ,& '   entries, and for building unique temporary file names (especially in         ' ,& '   cross-mounted filesystems that more than one OS is utilizing).               ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '    --method NAME  Select the UUID version type. Supported methods are          ' ,& '                   nil|0, random|4, time|1.                                     ' ,& '                                                                                ' ,& '                   0. Nil UUID (ie. ''''00000000-0000-0000-0000-000000000000'''')' ,& '                   1. time-based UUID                                           ' ,& '                   2. Not implemented                                           ' ,& '                   3. Not implemented                                           ' ,& '                   4. pseudo-RNG(Random Number Generator) based                 ' ,& '                   5. Not implemented                                           ' ,& '                                                                                ' ,& '    --urn       RFC 4122 defines a Uniform Resource Name (URN)                  ' ,& '                namespace for UUIDs. IE., the output is                         ' ,& '                prefixed with \"urn:uuid:\".                                      ' ,& '                                                                                ' ,& '    --repeat N  Number of UUID strings to generate                              ' ,& '                                                                                ' ,& '    --help      display this help and exit                                      ' ,& '                                                                                ' ,& '    --version   output version information and exit                             ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '  Sample commands                                                               ' ,& '                                                                                ' ,& '   unique                                                                       ' ,& '   4bb8051e-4af3-11e8-6603-4254ffee9a14                                         ' ,& '                                                                                ' ,& '   unique -urn                                                                  ' ,& '   urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a                                ' ,& '                                                                                ' ,& '   unique -method time -repeat 4                                                ' ,& '   f2a2faf0-833a-11e9-7373-5eb4cfd7e237                                         ' ,& '   f2a2faf0-833a-11e9-7373-afbb9f7b9100                                         ' ,& '   f2a2faf0-833a-11e9-7373-cde3ffff3681                                         ' ,& '   f2a2faf0-833a-11e9-7373-271cfbfd42bc                                         ' ,& '                                                                                ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] !> !!##NAME !!     unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string !!                   per RFC 4122 !!     (LICENSE:PD) !! !!##SYNOPSIS !! !!     unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version] !! !!##DESCRIPTION !!    unique(3f) generates UUID strings according to the RFC 4122 !!    standard. !! !!    A universally unique identifier (UUID) is a 128-bit number used to !!    identify information in computer systems. When generated according !!    to standard methods UUIDs are for practical purposes unique. !! !!    Standard methods 0,1, and 4 are supported as described in RFC 4122. !! !!    UUID strings are particularly useful as keys for relational database !!    entries, and for building unique temporary file names (especially in !!    cross-mounted filesystems that more than one OS is utilizing). !! !!##OPTIONS !!     --method NAME  Select the UUID version type. Supported methods are !!                    nil|0, random|4, time|1. !! !!                    0. Nil UUID (ie. ''00000000-0000-0000-0000-000000000000'') !!                    1. time-based UUID !!                    2. Not implemented !!                    3. Not implemented !!                    4. pseudo-RNG(Random Number Generator) based !!                    5. Not implemented !! !!     --urn       RFC 4122 defines a Uniform Resource Name (URN) !!                 namespace for UUIDs. IE., the output is !!                 prefixed with \"urn:uuid:\". !! !!     --repeat N  Number of UUID strings to generate !! !!     --help      display this help and exit !! !!     --version   output version information and exit !! !!##EXAMPLES !! !!   Sample commands !! !!    unique !!    4bb8051e-4af3-11e8-6603-4254ffee9a14 !! !!    unique -urn !!    urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a !! !!    unique -method time -repeat 4 !!    f2a2faf0-833a-11e9-7373-5eb4cfd7e237 !!    f2a2faf0-833a-11e9-7373-afbb9f7b9100 !!    f2a2faf0-833a-11e9-7373-cde3ffff3681 !!    f2a2faf0-833a-11e9-7373-271cfbfd42bc !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain end subroutine setup end program unique","tags":"","loc":"program/unique.html"},{"title":"demo_generate_uuid – M_uuid","text":"Uses M_uuid Contents Variables uuid Source Code demo_generate_uuid Variables Type Attributes Name Initial character(len=36) :: uuid Source Code program demo_generate_uuid use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid ! uuid = generate_uuid ( 1 ) ! version 1 (time-based UUID) write ( * , '(a36)' ) uuid ! uuid = generate_uuid ( 4 ) ! version 4 (pseudo-RNG-based), default ! ! RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. write ( * , '(\"urn:uuid:\",a36)' ) uuid ! ! a good scratch file name open ( file = '/tmp/scratch_' // uuid , unit = 10 ) ! end program demo_generate_uuid","tags":"","loc":"program/demo_generate_uuid.html"},{"title":"runtest – M_uuid","text":"Uses M_verify M_test_suite_M_uuid M_msg Contents Source Code runtest Source Code program runtest use M_msg use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level , unit_check_stop use M_test_suite_M_uuid implicit none unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_uuid () call unit_check_stop () end program runtest","tags":"","loc":"program/runtest.html"}]}