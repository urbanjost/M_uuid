var tipuesearch = {"pages":[{"title":" M_uuid ","text":"M_uuid M_uuid Name M_uuid(3f) - a module of UUID (Universally Unique IDentifier) procedures\n   (LICENSE:BSD-4-Clause) Synopsis use M_uuid, only : generate_uuid\n       function generate_uuid(version) result(uuid)\n       integer, intent(in), optional :: version\n       character(len=36) :: uuid Description Remember you are unique, just like everyone else . from Wikipedia … A universally unique identifier (UUID) is a 128-bit number used to\n   identify information on computer systems. In particular, they are\n   commonly used to create unique filenames and database and table keys. When generated according to the standard methods, UUIDs are for\n   practical purposes unique, without depending for their uniqueness\n   on a central registration authority or coordination between the\n   parties generating them, unlike most other numbering schemes. While\n   the probability that a UUID will be duplicated is not zero, it is\n   close enough to zero to be negligible. Thus, anyone can create a UUID and use it to identify something with\n   near certainty that the identifier does not duplicate one that has\n   already been or will be created to identify something else. Information\n   labeled with UUIDs by independent parties can therefore be later\n   combined into a single database, or transmitted on the same channel,\n   without needing to resolve conflicts between identifiers. Adoption of UUIDs and GUIDs is widespread. Many computing platforms\n   provide support for generating them, and for parsing their textual\n   representation. Note that several UUID types contain information that can be decyphered\n   to recreate the creation time or the MAC address of the device that\n   generated the UUID which has several uses for verifying when and\n   where data was generated. RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs.\n   A UUID presented as a URN appears as follows: urn:uuid:123e4567-e89b-12d3-a456-426655440000 Wikipedia contributors. (2021, September 21). Universally unique identifier. \n     In Wikipedia, The Free Encyclopedia. Retrieved 01:41, September 25, 2021, from\n     https://en.wikipedia.org/w/index.php?title=Universally_unique_identifier&oldid=1045581110 Example program demo_generate_uuid\n     ! generate 36-character UUID string\n     use M_uuid, only : generate_uuid\n     implicit none\n     character(len=36)   :: uuid\n     character(len=4096) :: filename\n        !\n    ! version 1 (time-based UUID)\n        uuid=generate_uuid(version=1) \n        write(*,'(a36)')uuid\n        !\n    ! version 4 (pseudo-RNG-based), default\n        uuid=generate_uuid(version=4)  \n        write(*,'(a36)')uuid\n        !\n        ! RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs.\n        write(*,'(\"urn:uuid:\",a36)')uuid\n        !\n        ! a good scratch file name\n        open(file='/tmp/scratch_'//uuid,unit=10)\n    inquire(unit=10,name=filename)\n    write(*,'(*(g0))') trim(filename)\n    close(unit=10,status='delete')\n     end program demo_generate_uuid Results: > 14d8c5e4-65a3-11ef-73c0-7686f8f3c380\n   > bdd1f289-24b7-40a9-625b-a4c4deefb0f2\n   > urn:uuid:bdd1f289-24b7-40a9-625b-a4c4deefb0f2\n   > /tmp/scratch_bdd1f289-24b7-40a9-625b-a4c4deefb0f2 Building the Module using make(1) git clone https : // github . com / urbanjost / M_uuid . git cd M_uuid / src # change Makefile if not using one of the listed compilers # for gfortran make clean make F90 = gfortran gfortran # for ifort make clean make F90 = ifort ifort # for nvfortran make clean make F90 = nvfortran nvfortran This will compile the Fortran module and basic example\nprogram that exercise the routine. Build and Test with FPM Alternatively, download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) bash\n        git clone https://github.com/urbanjost/M_uuid.git\n        cd M_uuid\n        fpm run \"*\"\n        fpm run --example \"*\"\n        fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_uuid = { git = \"https://github.com/urbanjost/M_uuid.git\" } Documentation User A single page that uses javascript to combine all the HTML\n     descriptions of the man-pages is at BOOK_M_uuid . a simple index to the man-pages in HTML form for the routines and programs There are man-pages in the repository download in the docs/ directory\n     that may be installed on ULS (Unix-Like Systems). manpages.zip manpages.tgz CHANGELOG provides a history of significant changes Developer ford(1) output . - github action status Pedigree This is a modified version of generate_uuid(3f).  generate_uuid(3f)\n   was originally derived from the xmlf90 codebase, (c) Alberto Garcia &\n   Jon Wakelin, 2003-2004.  It also calls RNG routines from Scott Ladd scott.ladd@coyotegulch.com , and the libFoX modules. Although some\n   sections have been replaced, generate_uuid(3f) was originally based\n   on the libFoX version. References RFC-4122 Wikipedia FOX Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"mtprng_state – M_uuid ","text":"type, public :: mtprng_state Components Type Visibility Attributes Name Initial integer(kind=INT64), public, dimension(0:N-1) :: mt integer(kind=INT32), public :: mti = -1","tags":"","url":"type/mtprng_state.html"},{"title":"setup – M_uuid","text":"subroutine setup() Arguments None Source Code subroutine setup () ! @(#)help_usage(3f): sets help information version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        unique(1)>                                           ' ,& '@(#)DESCRIPTION:    output a UUID (Universally Unique ID)>               ' ,& '@(#)VERSION:        1.0, 20180427>                                       ' ,& '@(#)AUTHOR:         John S. Urban>                                       ' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>      ' ,& '@(#)COMPILED:       Tue, Feb 9th, 2021 9:19:16 PM>                       ' ,& '' ] help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME' ,& '    unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string' ,& '                  per RFC 4122                                         ' ,& '    (LICENSE:PD)                                                       ' ,& '                                                                       ' ,& 'SYNOPSIS                                                               ' ,& '    unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version]  ' ,& '                                                                       ' ,& 'DESCRIPTION                                                            ' ,& '   unique(3f) generates UUID strings according to the RFC 4122 standard.' ,& '                                                                        ' ,& '   A universally unique identifier (UUID) is a 128-bit number used to   ' ,& '   identify information in computer systems. When generated according   ' ,& '   to standard methods UUIDs are for practical purposes unique.         ' ,& '                                                                        ' ,& '   Standard methods 0, 1 and 4 are supported as described in RFC 4122.  ' ,& '                                                                        ' ,& '   UUID strings are particularly useful as keys for relational database ' ,& '   entries, and for building unique temporary file names (especially in ' ,& '   cross-mounted filesystems that more than one OS is utilizing).       ' ,& '                                                                        ' ,& 'OPTIONS                                                                 ' ,& '    --method NAME  Select the UUID version type. Supported methods are  ' ,& '                   nil|0, random|4, time|1.                             ' ,& '                                                                        ' ,& '                   0. Nil UUID (ie. ''''00000000-0000-0000-0000-000000000000'''')' ,& '                   1. time-based UUID                                            ' ,& '                   2. Not implemented                                            ' ,& '                   3. Not implemented                                            ' ,& '                   4. pseudo-RNG(Random Number Generator) based. The default     ' ,& '                   5. Not implemented                                            ' ,& '                                                                                 ' ,& '    --urn       The output is prefixed with \"urn:uuid:\". This conforms to        ' ,& '                RFC 4122, which defines a Uniform Resource Name (URN)            ' ,& '                namespace for UUIDs.                                             ' ,& '                                                                                 ' ,& '    --repeat N  Number of UUID strings to generate                               ' ,& '                                                                                 ' ,& '    --help      display this help and exit                                       ' ,& '                                                                                 ' ,& '    --version   output version information and exit                              ' ,& '                                                                                 ' ,& 'EXAMPLES                                                                         ' ,& '  Sample commands                                                                ' ,& '                                                                                 ' ,& '   unique                                                                        ' ,& '   4bb8051e-4af3-11e8-6603-4254ffee9a14                                          ' ,& '                                                                                 ' ,& '   unique --urn                                                                  ' ,& '   urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a                                 ' ,& '                                                                                 ' ,& '   unique --method time --repeat 4                                               ' ,& '   f2a2faf0-833a-11e9-7373-5eb4cfd7e237                                          ' ,& '   f2a2faf0-833a-11e9-7373-afbb9f7b9100                                          ' ,& '   f2a2faf0-833a-11e9-7373-cde3ffff3681                                          ' ,& '   f2a2faf0-833a-11e9-7373-271cfbfd42bc                                          ' ,& '                                                                                 ' ,& '   unique --usage # show usage, including short names                            ' ,& '   USAGE:                                                                        ' ,& '   Keyword  Short Present Value                                                  ' ,& '   help        h  F        [F]                                                   ' ,& '   method      m  F        [\"4\"]                                                 ' ,& '   repeat      r  F        [1]                                                   ' ,& '   urn         U  F        [F]                                                   ' ,& '   usage       u  T        [T]                                                   ' ,& '   verbose     V  F        [F]                                                   ' ,& '   version     v  F        [F]                                                   ' ,& '                                                                                 ' ,& '   unique -r 2 -m 1 -U                                                           ' ,& '   urn:uuid:91c6a054-26df-11ee-5779-c946fe995111                                 ' ,& '   urn:uuid:91c6a054-26df-11ee-5779-62307afd65fd                                 ' ,& '                                                                                 ' ,& 'AUTHOR                                                                           ' ,& '   John S. Urban                                                                 ' ,& 'LICENSE                                                                          ' ,& '   Public Domain                                                                 ' ,& '' ] end subroutine setup","tags":"","url":"proc/setup.html"},{"title":"generate_uuid – M_uuid","text":"public  function generate_uuid(version) result(uuid) NAME generate_uuid ( 3 f ) - [ M_uuid ] generate a UUID ( Universally Unique IDentifier ) string per RFC 4122 ( LICENSE : BSD - 4 - Clause ) SYNOPSIS interface : function generate_uuid ( version ) result ( uuid ) integer , intent ( in ), optional :: version character ( len = 36 ) :: uuid DESCRIPTION A universally unique identifier ( UUID ) is a 128 - bit number used to identify information in computer systems . When generated according to standard methods UUIDs are for practical purposes unique . generate_uuid ( 3 f ) converts the UUID to a standard string format per RFC 4122 . AUTHORS based on previous work from Alberto Garcia & Jon Wakelin , 2003 - 2004. RNG routines from Scott Ladd < scott . ladd @coyotegulch . com > , and the libFoX library ( Toby White < tow @uszla . me . uk > , Gen - Tao Chiang < gtc25 @cam . ac . uk > , Andrew Walker < a . walker @ucl . ac . uk > ). OPTIONS version Indicates which standard method as described in RFC 4122 is used to generate the string . Versions 0 , 1 , and 4 are supported . 0 . Nil UUID ( ie . ' 00000000-0000-0000-0000-000000000000 ' ) 1 . time - based UUID 2 . Not implemented 3 . Not implemented 4 . pseudo - RNG ( Random Number Generator ) based 5 . Not implemented EXAMPLES Sample usage: program demo_generate_uuid ! generate 36 - character UUID string use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid character ( len = 4096 ) :: filename ! ! version 1 ( time - based UUID ) uuid = generate_uuid ( version = 1 ) write ( * , ' (a36) ' ) uuid ! ! version 4 ( pseudo - RNG - based ) , default uuid = generate_uuid ( version = 4 ) write ( * , ' (a36) ' ) uuid ! ! RFC 4122 defines a Uniform Resource Name ( URN ) namespace for UUIDs . write ( * , ' (\"urn:uuid:\",a36) ' ) uuid ! ! a good scratch file name open ( file = ' /tmp/scratch_ ' // uuid , unit = 10 ) inquire ( unit = 10 , name = filename ) write ( * , ' (*(g0)) ' ) trim ( filename ) close ( unit = 10 , status = ' delete ' ) end program demo_generate_uuid Results: > afa6bfb4-65a3-11ef-7251-52dbfec73ce6\n> 717b923d-c12f-4d99-6446-21b4fbed1337\n> urn:uuid:717b923d-c12f-4d99-6446-21b4fbed1337\n> /tmp/scratch_717b923d-c12f-4d99-6446-21b4fbed1337 Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: version Return Value character(len=36) Source Code function generate_uuid ( version ) result ( uuid ) ! ident_2=\"@(#) M_uuid generate_uuid(3f) generate(approximately) a UUID (Universally Unique IDentifier) string per RFC 4122\" integer , intent ( in ), optional :: version character ( len = 36 ) :: uuid integer ( kind = i8b ) :: timestamp , node integer ( kind = i4b ) :: clock_sequence integer ( kind = i4b ) :: time_low , time_mid , time_hi_and_version integer ( kind = i4b ) :: clk_seq_hi_res , clk_seq_low integer :: values ( 8 ) ! must be default for date_and_time integer ( kind = i4b ) :: variant , v if (. not . initialized ) then ! Use the current date and time to init mtprng but this gives limited variability, so mix the result up. ! Can we do better? In any case, this gets passed through a quick generator inside mtprng_init. call date_and_time ( values = values ) values ( 7 ) = values ( 7 ) * 1000 + values ( 5 ) * 100 + values ( 3 ) * 10 + values ( 1 ) values ( 8 ) = values ( 2 ) * 1000 + values ( 4 ) * 100 + values ( 6 ) * 10 + values ( 8 ) call mtprng_init ( int ( values ( 7 ) * 10000 + values ( 8 ), i4b ), rng_state ) clock_seq = int ( mtprng_rand64 ( rng_state ), i4b ) initialized = . true . endif variant = 1 if ( present ( version )) then v = version else v = 4 endif select case ( v ) case ( 0 ) uuid = '00000000-0000-0000-0000-000000000000' ! Nil UUID return case ( 1 ) !  version 1(time-based) call date_and_time ( values = values ) ! In case of too-frequent requests, we will replace time_low with the count below ... if ( all ( values == values_save )) then hires_count = hires_count + 1 else hires_count = 0 endif timestamp = get_utc_since_1582 ( values ) clock_sequence = clock_seq ! clock sequence (14 bits) node = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 16 )) ! node ( 48 bits) ! No MAC address accessible - see section 4.5 !FIXME case ( 2 - 3 , 5 ) ! Unimplemented uuid = '' return case ( 4 ) ! version 4 (pseudo-RNG-based) timestamp = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 28 )) clock_sequence = int ( mtprng_rand64 ( rng_state ), i4b ) ! clock sequence (14 bits) node = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 16 )) ! node ( 48 bits) case default ! Unspecified uuid = '' return end select time_low = ibits ( timestamp , 0 , 32 ) time_mid = ibits ( timestamp , 32 , 16 ) if ( hires_count == 0 ) then time_hi_and_version = ior ( int ( ibits ( timestamp , 48 , 12 ), i4b ), ishft ( v , 12 )) else time_hi_and_version = ior ( hires_count , ishft ( v , 12 )) endif clk_seq_low = ibits ( clock_sequence , 0 , 8 ) clk_seq_hi_res = ior ( ibits ( clock_sequence , 8 , 6 ), ishft ( variant , 6 )) uuid = int32ToHexOctets ( time_low , 4 ) // \"-\" // & int32ToHexOctets ( time_mid , 2 ) // \"-\" // & int32ToHexOctets ( time_hi_and_version , 2 ) // \"-\" // & int32ToHexOctets ( clk_seq_hi_res , 1 ) // & int32ToHexOctets ( clk_seq_low , 1 ) // \"-\" // & int64ToHexOctets ( node , 6 ) contains !==================================================================================================================================! function int32ToHexOctets ( b , n ) result ( s ) integer ( i4b ), intent ( in ) :: b integer , intent ( in ) :: n ! number of octets to print character ( len = 2 * n ) :: s character , parameter :: hexdigits ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] integer :: i do i = 0 , 2 * n - 1 s ( 2 * n - i : 2 * n - i ) = hexdigits ( ibits ( b , i * 4 , 4 )) enddo end function int32ToHexOctets !==================================================================================================================================! function int64ToHexOctets ( b , n ) result ( s ) integer ( i8b ), intent ( in ) :: b integer , intent ( in ) :: n ! number of octets to print character ( len = 2 * n ) :: s character , parameter :: hexdigits ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] integer :: i do i = 0 , 2 * n - 1 s ( 2 * n - i : 2 * n - i ) = hexdigits ( ibits ( b , i * 4 , 4 )) enddo end function int64ToHexOctets !==================================================================================================================================! end function generate_uuid","tags":"","url":"proc/generate_uuid.html"},{"title":"test_suite_m_uuid – M_uuid","text":"public  subroutine test_suite_m_uuid() Arguments None Source Code subroutine test_suite_m_uuid () ! this should contains tests for all public procedures in the module call test_generate_uuid () end subroutine test_suite_m_uuid","tags":"","url":"proc/test_suite_m_uuid.html"},{"title":"M_uuid – M_uuid","text":"generate_uuid(3f) was originally derived from the xmlf90 codebase, (c)\n Alberto Garcia & Jon Wakelin, 2003-2004. It also calls RNG routines from\n Scott Ladd scott.ladd@coyotegulch.com , and the libFoX modules. Although\n some sections have been replaced, generate_uuid(3f) was originally based\n on the libFoX version, with licensing as follows: ( c ) 2005 - 2009 Toby White < tow @uszla . me . uk > ( c ) 2007 - 2009 Gen - Tao Chiang < gtc25 @cam . ac . uk > ( c ) 2008 - 2012 Andrew Walker < a . walker @ucl . ac . uk > All rights reserved. Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met: Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its\n    contributors may be used to endorse or promote products derived from\n    this software without specific prior written permission. This software is provided by the copyright holders and contributors\n“AS IS” and any express or implied warranties, including, but not\nlimited to, the implied warranties of merchantability and fitness for\na particular purpose are disclaimed. in no event shall the copyright\nowner or contributors be liable for any direct, indirect, incidental,\nspecial, exemplary, or consequential damages (including, but not\nlimited to, procurement of substitute goods or services; loss of use,\ndata, or profits; or business interruption) however caused and on any\ntheory of liability, whether in contract, strict liability, or tort\n(including negligence or otherwise) arising in any way out of the use\nof this software, even if advised of the possibility of such damage. NAME M_uuid(3f) - [M_uuid::INTRO] a module of UUID (Universally Unique IDentifier) procedures\n(LICENSE:BSD-4-Clause) SYNOPSIS public entities: use M_uuid, only : generate_uuid\n  !\n  function generate_uuid(version) result(uuid)\n  integer, intent(in), optional :: version\n  character(len=36)             :: uuid DESCRIPTION Remember you are unique , just like everyone else . A universally unique identifier ( UUID ) is a 128 - bit number used to identify information in computer systems . When generated according to the standard methods , UUIDs are for practical purposes unique , without depending for their uniqueness on a central registration authority or coordination between the parties generating them , unlike most other numbering schemes . While the probability that a UUID will be duplicated is not zero , it is close enough to zero to be negligible . Thus , anyone can create a UUID and use it to identify something with near certainty that the identifier does not duplicate one that has already been or will be created to identify something else . Information labeled with UUIDs by independent parties can therefore be later combined into a single database , or transmitted on the same channel , without needing to resolve conflicts between identifiers . Adoption of UUIDs and GUIDs is widespread . Many computing platforms provide support for generating them , and for parsing their textual representation . RFC 4122 defines a Uniform Resource Name ( URN ) namespace for UUIDs . A UUID presented as a URN appears as follows: urn:uuid: 123e4567 - e89b - 12 d3 - a456 - 426655440000 – Wikipedia EXAMPLES Sample program : program demo_M_uuid ! generate 36 - character UUID string use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid character ( len = 4096 ) :: filename ! version 1 ( time - based UUID ) write ( * , ' (a36) ' ) generate_uuid ( version = 1 ) ! version 4 ( pseudo - RNG - based ) , default write ( * , ' (a36) ' ) generate_uuid ( version = 4 ) ! RFC 4122 defines a UUID Uniform Resource Name ( URN ) namespace write ( * , ' (\"urn:uuid:\",a36) ' ) generate_uuid ( version = 4 ) ! a good scratch file name open ( file = ' /tmp/scratch_ ' // generate_uuid () , unit = 10 ) inquire ( unit = 10 , name = filename ) write ( * , ' (*(g0)) ' ) trim ( filename ) close ( unit = 10 , status = ' delete ' ) end program demo_M_uuid Results: > 7bc99c22-65ae-11ef-5143-11d1be3150ff\n > dcdb2c0f-918f-4267-79f6-1612b35ef28b\n > urn:uuid:fe86c986-31ae-4b34-4e2e-beaed6f7391b\n > /tmp/scratch_fee7cac1-5756-4195-4102-2d34fd966af9 provide for routines extracted from other modules (M_time and M_random) Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: IEEE32 = selected_real_kind(6, 37) integer, public, parameter :: IEEE64 = selected_real_kind(15, 307) integer(kind=INT32), public, parameter :: M = 397_INT32 integer(kind=INT32), public, parameter :: N = 624_INT32 integer, public, parameter :: realtime = kind(0.0d0) Derived Types type, public :: mtprng_state Components Type Visibility Attributes Name Initial integer(kind=INT64), public, dimension(0:N-1) :: mt integer(kind=INT32), public :: mti = -1 Functions public  function generate_uuid (version) result(uuid) Sample usage: Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: version Return Value character(len=36)","tags":"","url":"module/m_uuid.html"},{"title":"M_test_suite_M_uuid – M_uuid","text":"Uses M_uuid M_framework__verify M_framework__msg Subroutines public  subroutine test_suite_m_uuid () Arguments None","tags":"","url":"module/m_test_suite_m_uuid.html"},{"title":"demo_M_uuid – M_uuid","text":"Uses M_uuid Variables Type Attributes Name Initial character(len=4096) :: filename character(len=36) :: uuid Source Code program demo_M_uuid ! generate 36-character UUID string use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid character ( len = 4096 ) :: filename ! version 1 (time-based UUID) write ( * , '(a36)' ) generate_uuid ( version = 1 ) ! version 4 (pseudo-RNG-based), default write ( * , '(a36)' ) generate_uuid ( version = 4 ) ! RFC 4122 defines a UUID Uniform Resource Name (URN) namespace write ( * , '(\"urn:uuid:\",a36)' ) generate_uuid ( version = 4 ) ! a good scratch file name open ( file = '/tmp/scratch_' // generate_uuid (), unit = 10 ) inquire ( unit = 10 , name = filename ) write ( * , '(*(g0))' ) trim ( filename ) close ( unit = 10 , status = 'delete' ) end program demo_M_uuid","tags":"","url":"program/demo_m_uuid.html"},{"title":"unique – M_uuid","text":"Uses M_uuid M_CLI2 iso_fortran_env Variables Type Attributes Name Initial character(len=:), allocatable :: help_text (:) integer :: i integer :: j character(len=10), allocatable :: methods (:) character(len=:), allocatable :: prefix integer :: repeat integer :: version character(len=:), allocatable :: version_text (:) Subroutines subroutine setup () Arguments None Source Code program unique ! this is a utility program. It is typically built using ccall(1). use M_CLI2 , only : set_args , lget , sgets , iget , unnamed use M_uuid , only : generate_uuid use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit implicit none integer :: version integer :: repeat integer :: i , j character ( len = 10 ), allocatable :: methods (:) character ( len = :), allocatable :: prefix character ( len = :), allocatable :: help_text (:) character ( len = :), allocatable :: version_text (:) ! define arguments, default values and crack command line call setup () call set_args ( '--method:m \"4\" --urn:U F --repeat:r 1' , help_text , version_text ) methods = [ character ( len = 10 ) :: sgets ( 'method' ), unnamed ] ! get value of command line argument -method or unnamed strings if ( size ( methods ). eq . 0 ) methods = [ \"4\" ] repeat = iget ( 'repeat' ) ! get value of command line argument -repeat prefix = merge ( 'urn:uuid:' , '         ' , lget ( 'urn' )) ! get value of command line argument -urn prefix = trim ( prefix ) do i = 1 , size ( methods ) select case ( methods ( i )) case ( '0' , 'nil' ); version = 0 case ( '1' , 'time' ); version = 1 case ( '' , '4' , 'random' ); version = 4 case default ; version = 4 write ( stderr , '(*(g0,1x))' ) '*unique* unknown method' , methods stop 1 endselect do j = 1 , repeat write ( * , '(2a)' ) prefix , generate_uuid ( version ) enddo enddo contains subroutine setup () ! @(#)help_usage(3f): sets help information version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        unique(1)>                                           ' ,& '@(#)DESCRIPTION:    output a UUID (Universally Unique ID)>               ' ,& '@(#)VERSION:        1.0, 20180427>                                       ' ,& '@(#)AUTHOR:         John S. Urban>                                       ' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>      ' ,& '@(#)COMPILED:       Tue, Feb 9th, 2021 9:19:16 PM>                       ' ,& '' ] help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME' ,& '    unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string' ,& '                  per RFC 4122                                         ' ,& '    (LICENSE:PD)                                                       ' ,& '                                                                       ' ,& 'SYNOPSIS                                                               ' ,& '    unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version]  ' ,& '                                                                       ' ,& 'DESCRIPTION                                                            ' ,& '   unique(3f) generates UUID strings according to the RFC 4122 standard.' ,& '                                                                        ' ,& '   A universally unique identifier (UUID) is a 128-bit number used to   ' ,& '   identify information in computer systems. When generated according   ' ,& '   to standard methods UUIDs are for practical purposes unique.         ' ,& '                                                                        ' ,& '   Standard methods 0, 1 and 4 are supported as described in RFC 4122.  ' ,& '                                                                        ' ,& '   UUID strings are particularly useful as keys for relational database ' ,& '   entries, and for building unique temporary file names (especially in ' ,& '   cross-mounted filesystems that more than one OS is utilizing).       ' ,& '                                                                        ' ,& 'OPTIONS                                                                 ' ,& '    --method NAME  Select the UUID version type. Supported methods are  ' ,& '                   nil|0, random|4, time|1.                             ' ,& '                                                                        ' ,& '                   0. Nil UUID (ie. ''''00000000-0000-0000-0000-000000000000'''')' ,& '                   1. time-based UUID                                            ' ,& '                   2. Not implemented                                            ' ,& '                   3. Not implemented                                            ' ,& '                   4. pseudo-RNG(Random Number Generator) based. The default     ' ,& '                   5. Not implemented                                            ' ,& '                                                                                 ' ,& '    --urn       The output is prefixed with \"urn:uuid:\". This conforms to        ' ,& '                RFC 4122, which defines a Uniform Resource Name (URN)            ' ,& '                namespace for UUIDs.                                             ' ,& '                                                                                 ' ,& '    --repeat N  Number of UUID strings to generate                               ' ,& '                                                                                 ' ,& '    --help      display this help and exit                                       ' ,& '                                                                                 ' ,& '    --version   output version information and exit                              ' ,& '                                                                                 ' ,& 'EXAMPLES                                                                         ' ,& '  Sample commands                                                                ' ,& '                                                                                 ' ,& '   unique                                                                        ' ,& '   4bb8051e-4af3-11e8-6603-4254ffee9a14                                          ' ,& '                                                                                 ' ,& '   unique --urn                                                                  ' ,& '   urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a                                 ' ,& '                                                                                 ' ,& '   unique --method time --repeat 4                                               ' ,& '   f2a2faf0-833a-11e9-7373-5eb4cfd7e237                                          ' ,& '   f2a2faf0-833a-11e9-7373-afbb9f7b9100                                          ' ,& '   f2a2faf0-833a-11e9-7373-cde3ffff3681                                          ' ,& '   f2a2faf0-833a-11e9-7373-271cfbfd42bc                                          ' ,& '                                                                                 ' ,& '   unique --usage # show usage, including short names                            ' ,& '   USAGE:                                                                        ' ,& '   Keyword  Short Present Value                                                  ' ,& '   help        h  F        [F]                                                   ' ,& '   method      m  F        [\"4\"]                                                 ' ,& '   repeat      r  F        [1]                                                   ' ,& '   urn         U  F        [F]                                                   ' ,& '   usage       u  T        [T]                                                   ' ,& '   verbose     V  F        [F]                                                   ' ,& '   version     v  F        [F]                                                   ' ,& '                                                                                 ' ,& '   unique -r 2 -m 1 -U                                                           ' ,& '   urn:uuid:91c6a054-26df-11ee-5779-c946fe995111                                 ' ,& '   urn:uuid:91c6a054-26df-11ee-5779-62307afd65fd                                 ' ,& '                                                                                 ' ,& 'AUTHOR                                                                           ' ,& '   John S. Urban                                                                 ' ,& 'LICENSE                                                                          ' ,& '   Public Domain                                                                 ' ,& '' ] end subroutine setup end program unique","tags":"","url":"program/unique.html"},{"title":"demo_generate_uuid – M_uuid","text":"Uses M_uuid Variables Type Attributes Name Initial character(len=4096) :: filename character(len=36) :: uuid Source Code program demo_generate_uuid ! generate 36-character UUID string use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid character ( len = 4096 ) :: filename ! ! version 1 (time-based UUID) uuid = generate_uuid ( version = 1 ) write ( * , '(a36)' ) uuid ! ! version 4 (pseudo-RNG-based), default uuid = generate_uuid ( version = 4 ) write ( * , '(a36)' ) uuid ! ! RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. write ( * , '(\"urn:uuid:\",a36)' ) uuid ! ! a good scratch file name open ( file = '/tmp/scratch_' // uuid , unit = 10 ) inquire ( unit = 10 , name = filename ) write ( * , '(*(g0))' ) trim ( filename ) close ( unit = 10 , status = 'delete' ) end program demo_generate_uuid","tags":"","url":"program/demo_generate_uuid.html"},{"title":"runtest – M_uuid","text":"Uses M_test_suite_M_uuid M_framework__verify M_framework__msg Source Code program runtest use M_framework__msg use M_framework__verify , only : unit_check_stop use M_test_suite_M_uuid implicit none call test_suite_M_uuid () call unit_check_stop () end program runtest","tags":"","url":"program/runtest.html"},{"title":"demo_M_uuid.f90 – M_uuid","text":"Source Code program demo_M_uuid ! generate 36-character UUID string use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid character ( len = 4096 ) :: filename ! version 1 (time-based UUID) write ( * , '(a36)' ) generate_uuid ( version = 1 ) ! version 4 (pseudo-RNG-based), default write ( * , '(a36)' ) generate_uuid ( version = 4 ) ! RFC 4122 defines a UUID Uniform Resource Name (URN) namespace write ( * , '(\"urn:uuid:\",a36)' ) generate_uuid ( version = 4 ) ! a good scratch file name open ( file = '/tmp/scratch_' // generate_uuid (), unit = 10 ) inquire ( unit = 10 , name = filename ) write ( * , '(*(g0))' ) trim ( filename ) close ( unit = 10 , status = 'delete' ) end program demo_M_uuid","tags":"","url":"sourcefile/demo_m_uuid.f90.html"},{"title":"unique.f90 – M_uuid","text":"Source Code program unique ! this is a utility program. It is typically built using ccall(1). use M_CLI2 , only : set_args , lget , sgets , iget , unnamed use M_uuid , only : generate_uuid use , intrinsic :: iso_fortran_env , only : stdin => input_unit , stdout => output_unit , stderr => error_unit implicit none integer :: version integer :: repeat integer :: i , j character ( len = 10 ), allocatable :: methods (:) character ( len = :), allocatable :: prefix character ( len = :), allocatable :: help_text (:) character ( len = :), allocatable :: version_text (:) ! define arguments, default values and crack command line call setup () call set_args ( '--method:m \"4\" --urn:U F --repeat:r 1' , help_text , version_text ) methods = [ character ( len = 10 ) :: sgets ( 'method' ), unnamed ] ! get value of command line argument -method or unnamed strings if ( size ( methods ). eq . 0 ) methods = [ \"4\" ] repeat = iget ( 'repeat' ) ! get value of command line argument -repeat prefix = merge ( 'urn:uuid:' , '         ' , lget ( 'urn' )) ! get value of command line argument -urn prefix = trim ( prefix ) do i = 1 , size ( methods ) select case ( methods ( i )) case ( '0' , 'nil' ); version = 0 case ( '1' , 'time' ); version = 1 case ( '' , '4' , 'random' ); version = 4 case default ; version = 4 write ( stderr , '(*(g0,1x))' ) '*unique* unknown method' , methods stop 1 endselect do j = 1 , repeat write ( * , '(2a)' ) prefix , generate_uuid ( version ) enddo enddo contains subroutine setup () ! @(#)help_usage(3f): sets help information version_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        unique(1)>                                           ' ,& '@(#)DESCRIPTION:    output a UUID (Universally Unique ID)>               ' ,& '@(#)VERSION:        1.0, 20180427>                                       ' ,& '@(#)AUTHOR:         John S. Urban>                                       ' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>      ' ,& '@(#)COMPILED:       Tue, Feb 9th, 2021 9:19:16 PM>                       ' ,& '' ] help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME' ,& '    unique(1f) - [FUNIX] generate a UUID (Universally Unique ID) string' ,& '                  per RFC 4122                                         ' ,& '    (LICENSE:PD)                                                       ' ,& '                                                                       ' ,& 'SYNOPSIS                                                               ' ,& '    unique [[ --method] NAME][ -urn][ -repeat N]]|[ --help|--version]  ' ,& '                                                                       ' ,& 'DESCRIPTION                                                            ' ,& '   unique(3f) generates UUID strings according to the RFC 4122 standard.' ,& '                                                                        ' ,& '   A universally unique identifier (UUID) is a 128-bit number used to   ' ,& '   identify information in computer systems. When generated according   ' ,& '   to standard methods UUIDs are for practical purposes unique.         ' ,& '                                                                        ' ,& '   Standard methods 0, 1 and 4 are supported as described in RFC 4122.  ' ,& '                                                                        ' ,& '   UUID strings are particularly useful as keys for relational database ' ,& '   entries, and for building unique temporary file names (especially in ' ,& '   cross-mounted filesystems that more than one OS is utilizing).       ' ,& '                                                                        ' ,& 'OPTIONS                                                                 ' ,& '    --method NAME  Select the UUID version type. Supported methods are  ' ,& '                   nil|0, random|4, time|1.                             ' ,& '                                                                        ' ,& '                   0. Nil UUID (ie. ''''00000000-0000-0000-0000-000000000000'''')' ,& '                   1. time-based UUID                                            ' ,& '                   2. Not implemented                                            ' ,& '                   3. Not implemented                                            ' ,& '                   4. pseudo-RNG(Random Number Generator) based. The default     ' ,& '                   5. Not implemented                                            ' ,& '                                                                                 ' ,& '    --urn       The output is prefixed with \"urn:uuid:\". This conforms to        ' ,& '                RFC 4122, which defines a Uniform Resource Name (URN)            ' ,& '                namespace for UUIDs.                                             ' ,& '                                                                                 ' ,& '    --repeat N  Number of UUID strings to generate                               ' ,& '                                                                                 ' ,& '    --help      display this help and exit                                       ' ,& '                                                                                 ' ,& '    --version   output version information and exit                              ' ,& '                                                                                 ' ,& 'EXAMPLES                                                                         ' ,& '  Sample commands                                                                ' ,& '                                                                                 ' ,& '   unique                                                                        ' ,& '   4bb8051e-4af3-11e8-6603-4254ffee9a14                                          ' ,& '                                                                                 ' ,& '   unique --urn                                                                  ' ,& '   urn:uuid:e9fd7cab-69f2-4cd6-4b5e-d54b9fbf617a                                 ' ,& '                                                                                 ' ,& '   unique --method time --repeat 4                                               ' ,& '   f2a2faf0-833a-11e9-7373-5eb4cfd7e237                                          ' ,& '   f2a2faf0-833a-11e9-7373-afbb9f7b9100                                          ' ,& '   f2a2faf0-833a-11e9-7373-cde3ffff3681                                          ' ,& '   f2a2faf0-833a-11e9-7373-271cfbfd42bc                                          ' ,& '                                                                                 ' ,& '   unique --usage # show usage, including short names                            ' ,& '   USAGE:                                                                        ' ,& '   Keyword  Short Present Value                                                  ' ,& '   help        h  F        [F]                                                   ' ,& '   method      m  F        [\"4\"]                                                 ' ,& '   repeat      r  F        [1]                                                   ' ,& '   urn         U  F        [F]                                                   ' ,& '   usage       u  T        [T]                                                   ' ,& '   verbose     V  F        [F]                                                   ' ,& '   version     v  F        [F]                                                   ' ,& '                                                                                 ' ,& '   unique -r 2 -m 1 -U                                                           ' ,& '   urn:uuid:91c6a054-26df-11ee-5779-c946fe995111                                 ' ,& '   urn:uuid:91c6a054-26df-11ee-5779-62307afd65fd                                 ' ,& '                                                                                 ' ,& 'AUTHOR                                                                           ' ,& '   John S. Urban                                                                 ' ,& 'LICENSE                                                                          ' ,& '   Public Domain                                                                 ' ,& '' ] end subroutine setup end program unique","tags":"","url":"sourcefile/unique.f90.html"},{"title":"demo_generate_uuid.f90 – M_uuid","text":"Source Code program demo_generate_uuid ! generate 36-character UUID string use M_uuid , only : generate_uuid implicit none character ( len = 36 ) :: uuid character ( len = 4096 ) :: filename ! ! version 1 (time-based UUID) uuid = generate_uuid ( version = 1 ) write ( * , '(a36)' ) uuid ! ! version 4 (pseudo-RNG-based), default uuid = generate_uuid ( version = 4 ) write ( * , '(a36)' ) uuid ! ! RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. write ( * , '(\"urn:uuid:\",a36)' ) uuid ! ! a good scratch file name open ( file = '/tmp/scratch_' // uuid , unit = 10 ) inquire ( unit = 10 , name = filename ) write ( * , '(*(g0))' ) trim ( filename ) close ( unit = 10 , status = 'delete' ) end program demo_generate_uuid","tags":"","url":"sourcefile/demo_generate_uuid.f90.html"},{"title":"M_uuid.f90 – M_uuid","text":"Source Code !> !! generate_uuid(3f) was originally derived from the xmlf90 codebase, (c) !! Alberto Garcia & Jon Wakelin, 2003-2004. It also calls RNG routines from !! Scott Ladd <scott.ladd@coyotegulch.com>, and the libFoX modules. Although !! some sections have been replaced, generate_uuid(3f) was originally based !! on the libFoX version, with licensing as follows: !! !!     (c) 2005-2009 Toby White <tow@uszla.me.uk> !!     (c) 2007-2009 Gen-Tao Chiang <gtc25@cam.ac.uk> !!     (c) 2008-2012 Andrew Walker <a.walker@ucl.ac.uk> !! !! All rights reserved. !! !!  + Redistribution and use in source and binary forms, with or without !!    modification, are permitted provided that the following conditions !!    are met: !! !!  + Redistributions of source code must retain the above copyright notice, !!    this list of conditions and the following disclaimer. !! !!  + Redistributions in binary form must reproduce the above copyright !!    notice, this list of conditions and the following disclaimer in the !!    documentation and/or other materials provided with the distribution. !! !!  + Neither the name of the copyright holder nor the names of its !!    contributors may be used to endorse or promote products derived from !!    this software without specific prior written permission. !! !!    This software is provided by the copyright holders and contributors !!    \"AS IS\" and any express or implied warranties, including, but not !!    limited to, the implied warranties of merchantability and fitness for !!    a particular purpose are disclaimed. in no event shall the copyright !!    owner or contributors be liable for any direct, indirect, incidental, !!    special, exemplary, or consequential damages (including, but not !!    limited to, procurement of substitute goods or services; loss of use, !!    data, or profits; or business interruption) however caused and on any !!    theory of liability, whether in contract, strict liability, or tort !!    (including negligence or otherwise) arising in any way out of the use !!    of this software, even if advised of the possibility of such damage. module M_uuid !> !!##NAME !!    M_uuid(3f) - [M_uuid::INTRO] a module of UUID (Universally Unique IDentifier) procedures !!    (LICENSE:BSD-4-Clause) !! !!##SYNOPSIS !! !!  public entities: !! !!      use M_uuid, only : generate_uuid !!      ! !!      function generate_uuid(version) result(uuid) !!      integer, intent(in), optional :: version !!      character(len=36)             :: uuid !! !!##DESCRIPTION !! !!    Remember you are unique, just like everyone else. !! !!    A universally unique identifier (UUID) is a 128-bit number used to !!    identify information in computer systems. !! !!    When generated according to the standard methods, UUIDs are for !!    practical purposes unique, without depending for their uniqueness !!    on a central registration authority or coordination between the !!    parties generating them, unlike most other numbering schemes. While !!    the probability that a UUID will be duplicated is not zero, it is !!    close enough to zero to be negligible. !! !!    Thus, anyone can create a UUID and use it to identify something with !!    near certainty that the identifier does not duplicate one that has !!    already been or will be created to identify something else. Information !!    labeled with UUIDs by independent parties can therefore be later !!    combined into a single database, or transmitted on the same channel, !!    without needing to resolve conflicts between identifiers. !! !!    Adoption of UUIDs and GUIDs is widespread. Many computing platforms !!    provide support for generating them, and for parsing their textual !!    representation. !! !!    RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. !!    A UUID presented as a URN appears as follows: !! !!       urn:uuid:123e4567-e89b-12d3-a456-426655440000 !! !! -- Wikipedia !! !!##EXAMPLES !! !!    Sample program: !! !!     program demo_M_uuid !!     ! generate 36-character UUID string !!     use M_uuid, only : generate_uuid !!     implicit none !!     character(len=36)   :: uuid !!     character(len=4096) :: filename !!        ! version 1 (time-based UUID) !!        write(*,'(a36)') generate_uuid(version=1) !!        ! version 4 (pseudo-RNG-based), default !!        write(*,'(a36)') generate_uuid(version=4) !!        ! RFC 4122 defines a UUID Uniform Resource Name (URN) namespace !!        write(*,'(\"urn:uuid:\",a36)') generate_uuid(version=4) !!        ! a good scratch file name !!        open(file='/tmp/scratch_'//generate_uuid(),unit=10) !!        inquire(unit=10,name=filename) !!        write(*,'(*(g0))') trim(filename) !!        close(unit=10,status='delete') !!     end program demo_M_uuid !! !!  Results: !! !!     > 7bc99c22-65ae-11ef-5143-11d1be3150ff !!     > dcdb2c0f-918f-4267-79f6-1612b35ef28b !!     > urn:uuid:fe86c986-31ae-4b34-4e2e-beaed6f7391b !!     > /tmp/scratch_fee7cac1-5756-4195-4102-2d34fd966af9 !=================================================================================================================================== !use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, dp=>real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 !! provide for routines extracted from other modules (M_time and M_random) implicit none integer , parameter :: realtime = kind ( 0.0d0 ) ! type for unix epoch time and julian days ! Kind types for IEEE 754/IEC 60559 single- and double-precision reals integer , parameter :: IEEE32 = selected_real_kind ( 6 , 37 ) integer , parameter :: IEEE64 = selected_real_kind ( 15 , 307 ) ! Constants integer ( INT32 ), parameter :: N = 624_INT32 integer ( INT32 ), parameter :: M = 397_INT32 real ( kind = realtime ), parameter , private :: SECDAY = 8640 0.0d0 ! 24:00:00 hours as seconds type mtprng_state integer ( INT32 ) :: mti = - 1 integer ( INT64 ), dimension ( 0 : N - 1 ) :: mt end type !=================================================================================================================================== !=================================================================================================================================== private ! ident_1=\"@(#) M_uuid M_uid(3fm) generate UUIDs according to RFC 4122\" ! Only versions 0(Nil), 1 (time-based) and 4 (pseudo-RNG-based) are implemented. integer , parameter :: i4b = selected_int_kind ( 9 ) integer , parameter :: i8b = selected_int_kind ( 18 ) type ( mtprng_state ), save :: rng_state logical , save :: initialized = . false . integer , save :: values_save ! must be default for date_and_time integer ( kind = i4b ), save :: hires_count = 0 integer , save :: clock_seq = 0 ! a random number constant for the lifetime of the process. best we can do per S 4.1.5 public :: generate_uuid contains !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! !> !!##NAME !!    generate_uuid(3f) - [M_uuid] generate a UUID (Universally Unique IDentifier) string per RFC 4122 !!    (LICENSE:BSD-4-Clause) !! !!##SYNOPSIS !! !!    interface: !! !!        function generate_uuid(version) result(uuid) !!        integer, intent(in), optional :: version !!        character(len=36)             :: uuid !! !!##DESCRIPTION !!    A universally unique identifier (UUID) is a 128-bit number used to !!    identify information in computer systems. When generated according !!    to standard methods UUIDs are for practical purposes unique. !!    generate_uuid(3f) converts the UUID to a standard string format !!    per RFC 4122. !! !!##AUTHORS !!    based on previous work from Alberto Garcia & Jon Wakelin, 2003-2004. !!    RNG routines from Scott Ladd <scott.ladd@coyotegulch.com>, and !!    the libFoX library( Toby White <tow@uszla.me.uk>, Gen-Tao Chiang !!    <gtc25@cam.ac.uk>, Andrew Walker <a.walker@ucl.ac.uk>). !! !!##OPTIONS !!    version  Indicates which standard method as described in RFC 4122 !!             is used to generate the string. Versions 0,1, and 4 are supported. !! !!             0.  Nil UUID (ie. '00000000-0000-0000-0000-000000000000') !!             1.  time-based UUID !!             2.  Not implemented !!             3.  Not implemented !!             4.  pseudo-RNG(Random Number Generator) based !!             5.  Not implemented !! !!##EXAMPLES !! !!   Sample usage: !! !!      program demo_generate_uuid !!      ! generate 36-character UUID string !!      use M_uuid, only : generate_uuid !!      implicit none !!      character(len=36)   :: uuid !!      character(len=4096) :: filename !!         ! !!         ! version 1 (time-based UUID) !!         uuid=generate_uuid(version=1) !!         write(*,'(a36)')uuid !!         ! !!         ! version 4 (pseudo-RNG-based), default !!         uuid=generate_uuid(version=4) !!         write(*,'(a36)')uuid !!         ! !!         ! RFC 4122 defines a Uniform Resource Name (URN) namespace for UUIDs. !!         write(*,'(\"urn:uuid:\",a36)')uuid !!         ! !!         ! a good scratch file name !!         open(file='/tmp/scratch_'//uuid,unit=10) !!         inquire(unit=10,name=filename) !!         write(*,'(*(g0))') trim(filename) !!         close(unit=10,status='delete') !!      end program demo_generate_uuid !! !! Results: !! !!    > afa6bfb4-65a3-11ef-7251-52dbfec73ce6 !!    > 717b923d-c12f-4d99-6446-21b4fbed1337 !!    > urn:uuid:717b923d-c12f-4d99-6446-21b4fbed1337 !!    > /tmp/scratch_717b923d-c12f-4d99-6446-21b4fbed1337 function generate_uuid ( version ) result ( uuid ) ! ident_2=\"@(#) M_uuid generate_uuid(3f) generate(approximately) a UUID (Universally Unique IDentifier) string per RFC 4122\" integer , intent ( in ), optional :: version character ( len = 36 ) :: uuid integer ( kind = i8b ) :: timestamp , node integer ( kind = i4b ) :: clock_sequence integer ( kind = i4b ) :: time_low , time_mid , time_hi_and_version integer ( kind = i4b ) :: clk_seq_hi_res , clk_seq_low integer :: values ( 8 ) ! must be default for date_and_time integer ( kind = i4b ) :: variant , v if (. not . initialized ) then ! Use the current date and time to init mtprng but this gives limited variability, so mix the result up. ! Can we do better? In any case, this gets passed through a quick generator inside mtprng_init. call date_and_time ( values = values ) values ( 7 ) = values ( 7 ) * 1000 + values ( 5 ) * 100 + values ( 3 ) * 10 + values ( 1 ) values ( 8 ) = values ( 2 ) * 1000 + values ( 4 ) * 100 + values ( 6 ) * 10 + values ( 8 ) call mtprng_init ( int ( values ( 7 ) * 10000 + values ( 8 ), i4b ), rng_state ) clock_seq = int ( mtprng_rand64 ( rng_state ), i4b ) initialized = . true . endif variant = 1 if ( present ( version )) then v = version else v = 4 endif select case ( v ) case ( 0 ) uuid = '00000000-0000-0000-0000-000000000000' ! Nil UUID return case ( 1 ) !  version 1(time-based) call date_and_time ( values = values ) ! In case of too-frequent requests, we will replace time_low with the count below ... if ( all ( values == values_save )) then hires_count = hires_count + 1 else hires_count = 0 endif timestamp = get_utc_since_1582 ( values ) clock_sequence = clock_seq ! clock sequence (14 bits) node = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 16 )) ! node ( 48 bits) ! No MAC address accessible - see section 4.5 !FIXME case ( 2 - 3 , 5 ) ! Unimplemented uuid = '' return case ( 4 ) ! version 4 (pseudo-RNG-based) timestamp = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 28 )) clock_sequence = int ( mtprng_rand64 ( rng_state ), i4b ) ! clock sequence (14 bits) node = ior ( mtprng_rand64 ( rng_state ), ishft ( mtprng_rand64 ( rng_state ), 16 )) ! node ( 48 bits) case default ! Unspecified uuid = '' return end select time_low = ibits ( timestamp , 0 , 32 ) time_mid = ibits ( timestamp , 32 , 16 ) if ( hires_count == 0 ) then time_hi_and_version = ior ( int ( ibits ( timestamp , 48 , 12 ), i4b ), ishft ( v , 12 )) else time_hi_and_version = ior ( hires_count , ishft ( v , 12 )) endif clk_seq_low = ibits ( clock_sequence , 0 , 8 ) clk_seq_hi_res = ior ( ibits ( clock_sequence , 8 , 6 ), ishft ( variant , 6 )) uuid = int32ToHexOctets ( time_low , 4 ) // \"-\" // & int32ToHexOctets ( time_mid , 2 ) // \"-\" // & int32ToHexOctets ( time_hi_and_version , 2 ) // \"-\" // & int32ToHexOctets ( clk_seq_hi_res , 1 ) // & int32ToHexOctets ( clk_seq_low , 1 ) // \"-\" // & int64ToHexOctets ( node , 6 ) contains !==================================================================================================================================! function int32ToHexOctets ( b , n ) result ( s ) integer ( i4b ), intent ( in ) :: b integer , intent ( in ) :: n ! number of octets to print character ( len = 2 * n ) :: s character , parameter :: hexdigits ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] integer :: i do i = 0 , 2 * n - 1 s ( 2 * n - i : 2 * n - i ) = hexdigits ( ibits ( b , i * 4 , 4 )) enddo end function int32ToHexOctets !==================================================================================================================================! function int64ToHexOctets ( b , n ) result ( s ) integer ( i8b ), intent ( in ) :: b integer , intent ( in ) :: n ! number of octets to print character ( len = 2 * n ) :: s character , parameter :: hexdigits ( 0 : 15 ) = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] integer :: i do i = 0 , 2 * n - 1 s ( 2 * n - i : 2 * n - i ) = hexdigits ( ibits ( b , i * 4 , 4 )) enddo end function int64ToHexOctets !==================================================================================================================================! end function generate_uuid !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! function get_utc_since_1582 ( values ) result ( ns ) !use, intrinsic :: iso_fortran_env, only : wp=>real128 use , intrinsic :: iso_fortran_env , only : wp => real64 ! returns the number of 100-ns intervals since 1582-10-15T00:00:00-0 ! Not really: Assuming only used as an internal routine for M_UUID(3fm) !   Fortran date time arrays only report up to the millisecond, !   and assuming any date given is after 2017 (because added leapseconds up till that date) !   and not taking account of leapseconds after 2017, and assuming !   if get same answer on multiple calls that caller will correct or try again, as goal is to generate unique values integer , intent ( in ) :: values ( 8 ) integer ( kind = i8b ) :: ns real ( kind = realtime ) :: unixtime real ( kind = realtime ) :: starttime integer :: ierr integer :: clicks , maxclicks real :: rate real ( kind = wp ) :: rate8 , frac8 integer ( kind = i8b ) :: frac integer , parameter :: ref ( 8 ) = [ 1582 , 10 , 15 , 0 , 0 , 0 , 0 , 0 ] call date_to_unix ( ref , starttime , ierr ) ! seconds from 1582-10-15-00-00-00 to Unix Epoch Time call date_to_unix ( values , unixtime , ierr ) ! seconds from given date to Unix Epoch Time ! if system clock is higher resolution use it even though that makes fractional second wrong call system_clock ( count = clicks , count_rate = rate , count_max = maxclicks ) if ( rate > 1000 ) then ! system clock available and higher resolution rate8 = real ( rate , kind = wp ) frac8 = mod ( real ( clicks , kind = wp ), rate8 ) / rate8 * 10000000_i8b ! MOD(A,P) == A - INT (A/P) * P. frac = int ( frac8 ) ! truncate to one remainder of one second ns = int (( unixtime - starttime ) * 10000000_i8b , kind = i8b ) + frac ! get date and time to nearest second and add frac else ! use date even though accurate only to 1/1000 second ns = int ( unixtime * 10000000_i8b , kind = i8b ) - int ( starttime * 10000000_i8b , kind = i8b ) endif ns = ns + 26_i8b ! leap seconds as of 2016 at 23:59:60 UTC end function get_utc_since_1582 !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! ! ROUTINES EXTRACTED FROM OTHER MODULES TO PROVIDE PORTABILITY !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    date_to_julian(3f) - [M_time:JULIAN] converts DAT date-time array to !!    Julian Date !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine date_to_julian(dat,juliandate,ierr) !! !!     integer,intent(in)               :: dat(8) !!     real(kind=realtime),intent(out)  :: juliandate !!     integer,intent(out)              :: ierr !! !!##DESCRIPTION !!    Converts a DAT date-time array to a Unix Epoch Time (UET) value. !!    UET is the number of seconds since 00:00 on January 1st, 1970, UTC. !! !!##OPTIONS !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!           dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !! !!##RETURNS !!    juliandate  A Julian Ephemeris Date (JED) is the number of days since !!                noon (not midnight) on January 1st, 4713 BC. !!    ierr        Error code. If 0 no error occurred. !! !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_date_to_julian !!     use M_time, only : date_to_julian,realtime !!     implicit none !!     integer             :: dat(8) !!     real(kind=realtime) :: juliandate !!     integer             :: ierr !!        ! generate DAT array !!        call date_and_time(values=dat) !!        ! show DAT array !!        write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!        ! convert DAT to Julian Date !!        call date_to_julian(dat,juliandate,ierr) !!        write(*,*)'Julian Date is ',juliandate !!        write(*,*)'ierr is ',ierr !!     end program demo_date_to_julian !! !!    results: !! !!     Today is:2016:7:19:-240:11:3:13:821 !!     Julian Date is    2457589.1272432986 !!     ierr is            0 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine date_to_julian ( dat , julian , ierr ) !----------------------------------------------------------------------------------------------------------------------------------- !> !! AUTHOR:    John S. Urban !!##VERSION:   1.0 2015-12-21 !! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19 ! * There is no year zero ! * Julian Date must be non-negative ! * Julian Date starts at noon; while Civil Calendar date starts at midnight !----------------------------------------------------------------------------------------------------------------------------------- ! ident_3=\"@(#) M_time date_to_julian(3f) Converts proleptic Gregorian DAT date-time array to Julian Date\" integer , intent ( in ) :: dat ( 8 ) ! array like returned by DATE_AND_TIME(3f) real ( kind = realtime ), intent ( out ) :: julian ! Julian Date (non-negative, but may be non-integer) integer , intent ( out ) :: ierr ! Error return: 0 =successful execution,-1=invalid year,-2=invalid month,-3=invalid day ! -4=invalid date (29th Feb, non leap-year) integer :: year , month , day , utc , hour , minute real ( kind = realtime ) :: second integer :: A , Y , M , JDN !----------------------------------------------------------------------------------------------------------------------------------- year = dat ( 1 ) ! Year month = dat ( 2 ) ! Month day = dat ( 3 ) ! Day utc = dat ( 4 ) * 60 ! Delta from UTC, convert from minutes to seconds hour = dat ( 5 ) ! Hour minute = dat ( 6 ) ! Minute second = dat ( 7 ) - utc + dat ( 8 ) / 100 0.0d0 ! Second   ! correction for time zone and milliseconds !----------------------------------------------------------------------------------------------------------------------------------- julian = - HUGE ( 99999 ) ! this is the date if an error occurs and IERR is < 0 !----------------------------------------------------------------------------------------------------------------------------------- if ( year == 0 . or . year . lt . - 4713 ) then ierr =- 1 return endif !----------------------------------------------------------------------------------------------------------------------------------- !  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) A = ( 14 - month ) / 12 ! A will be 1 for January or February, and 0 for other months, with integer truncation Y = year + 4800 - A M = month + 12 * A - 3 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero !  Staring from a Gregorian calendar date JDN = day + ( 153 * M + 2 ) / 5 + 365 * Y + Y / 4 - Y / 100 + Y / 400 - 32045 !  with integer truncation !  Finding the Julian Calendar date given the JDN (Julian day number) and time of day julian = JDN + dble ( hour - 12 ) / 2 4.0d0 + dble ( minute ) / 144 0.0d0 + second / 8640 0.0d0 !----------------------------------------------------------------------------------------------------------------------------------- if ( julian . lt . 0.d0 ) then ! Julian Day must be non-negative ierr = 1 else ierr = 0 endif !----------------------------------------------------------------------------------------------------------------------------------- end subroutine date_to_julian !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    date_to_unix(3f) - [M_time:UNIX_EPOCH] converts DAT date-time array to Unix !!    Epoch Time !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine date_to_unix(dat,unixtime,ierr) !! !!     integer,intent(in)               :: dat(8) !!     real(kind=realtime),intent(out)  :: unixtime !!     integer,intent(out)              :: ierr !! !!##DESCRIPTION !!    Converts a DAT date-time array to a UET (Unix Epoch Time). !! !!##OPTIONS !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!              dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !!##RETURNS !!    unixtime  The \"Unix Epoch\" time, or the number of seconds since !!              00:00:00 on January 1st, 1970, UTC. !!    ierr      Error code. If 0 no error occurred. !! !!##EXAMPLE !! !!     Sample program: !! !!      program demo_date_to_unix !!      use M_time, only : date_to_unix, realtime !!      implicit none !!      integer             :: dat(8) !!      real(kind=realtime) :: unixtime !!      integer             :: ierr !!         call date_and_time(values=dat) !!         write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!         call date_to_unix(dat,unixtime,ierr) !!         write(*,*)'Unix Epoch time is ',unixtime !!         write(*,*)'ierr is ',ierr !!      end program demo_date_to_unix !! !!     results: !! !!      Today is:2016:7:18:-240:23:44:20:434 !!      Unix Epoch time is    1468899860.4340105 !!      ierr is            0 !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine date_to_unix ( dat , unixtime , ierr ) ! ident_4=\"@(#) M_time date_to_unix(3f) Convert DAT date-time array to Unix Epoch Time\" integer , intent ( in ) :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME real ( kind = realtime ), intent ( out ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: ierr ! return 0 on success, otherwise 1 real ( kind = realtime ) :: julian real ( kind = realtime ), save :: julian_at_epoch logical , save :: first = . true . integer , parameter :: ref ( 8 ) = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Convert zero of Unix Epoch Time to Julian Date and save call date_to_julian ( ref , julian_at_epoch , ierr ) if ( ierr . ne . 0 ) return ! Error first = . false . endif !----------------------------------------------------------------------------------------------------------------------------------- call date_to_julian ( dat , julian , ierr ) if ( ierr . ne . 0 ) return ! Error unixtime = ( julian - julian_at_epoch ) * secday end subroutine date_to_unix !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! !> !!##NAME !!    mtprng_init(3f) - [M_random:MERSENNE TWISTER] Initialize the Mersenne Twister random number generator with \"seed\" !!    (LICENSE:BSD-4-Clause) !! !!##SYNOPSIS !! !!    subroutine mtprng_init(seed, state) !!    integer(INT32),     intent(in)  :: seed !!    type(mtprng_state), intent(out) :: state !! !!##DESCRIPTION !!    Initializes the Mersenne Twister random number generator with \"seed\" !! !!##OPTIONS !!    seed   A seed value is used to start a specific sequence of pseudo-random numbers !!    state  generator state initialized by mtprng_init(3f) or mtprng_init_array(3f) !! !!##EXAMPLE !! !!   Sample program: !! !!    program demo_mtprng_init !!    use M_random, only : mtprng_state, mtprng_init, mtprng_rand64 !!    use, intrinsic :: iso_fortran_env, only : int32, int64 !!    implicit none !!    integer(INT32) :: seed !!    type(mtprng_state) :: state !!       GET_SEED: block !!       integer :: count !!       integer :: count_rate !!          call system_clock(count, count_rate) !!          seed=count !!       endblock GET_SEED !!      call mtprng_init(seed, state) !!      ! returns a INT64 integer with a range in 0 .. 2&#94;32-1 !!      write(*,*) mtprng_rand64(state) !!    end program demo_mtprng_init !! !!   Sample Results: !! !!      867010878 subroutine mtprng_init ( seed , state ) ! ident_5=\"@(#) M_random mtprng_int(3f) Initializes the Mersenne Twister random number generator with \"seed\"\" ! arguments integer ( INT32 ), intent ( in ) :: seed type ( mtprng_state ), intent ( out ) :: state ! working storage integer :: i ! save seed state % mt ( 0 ) = seed ! Set the seed using values suggested by Matsumoto & Nishimura, using !   a generator by Knuth. See original source for details. do i = 1 , N - 1 state % mt ( i ) = iand ( 4294967295_INT64 , 1812433253_INT64 * ieor ( state % mt ( i - 1 ), ishft ( state % mt ( i - 1 ), - 30_INT64 )) + i ) enddo state % mti = N end subroutine mtprng_init !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! !> !!##NAME !!    mtprng_rand64(3f) - [M_random:MERSENNE TWISTER] Obtain the next 64-bit integer in the pseudo-random sequence !!    (LICENSE:BSD-4-Clause) !! !!##SYNOPSIS !! !!    function mtprng_rand64(state) result(r) !!    type(mtprng_state), intent(inout) :: state !!    integer(INT64) :: r !! !!##DESCRIPTION !!    Obtain the next 64-bit integer in the pseudo-random sequence in the range 0 to 2&#94;32-1. !!    Note that the range is considerably below the value of HUGE(0_int64). !! !!##OPTIONS !!    state  generator state initialized by mtprng_init(3f) or mtprng_init_array(3f) !! !!##RETURNS !!    r      next pseudo-random value in the range 0 to 2&#94;32-1 !! !!##EXAMPLE !! !!   Sample program: !! !!    program demo_mtprng_rand64 !!    use M_random, only : mtprng_state, mtprng_init, mtprng_rand64 !!    use, intrinsic :: iso_fortran_env, only : int32, int64 !!    implicit none !!    integer(INT32) :: seed !!    type(mtprng_state) :: state !!      GET_SEED: block !!      integer :: count !!      integer :: count_rate !!         call system_clock(count, count_rate) !!      seed = count !!      endblock GET_SEED !!      call mtprng_init(seed, state) !!      write(*,*) mtprng_rand64(state) !!    end program demo_mtprng_rand64 function mtprng_rand64 ( state ) result ( r ) ! ident_6=\"@(#) M_random mtprng_rand64(3f) Obtain the next 64-bit integer in the pseudo-random sequence\" ! arguments type ( mtprng_state ), intent ( inout ) :: state !return type integer ( INT64 ) :: r ! internal constants integer ( INT64 ), dimension ( 0 : 1 ), parameter :: mag01 = ( / 0_INT64 , - 1727483681_INT64 / ) ! Period parameters integer ( INT64 ), parameter :: UPPER_MASK = 2147483648_INT64 integer ( INT64 ), parameter :: LOWER_MASK = 2147483647_INT64 ! Tempering parameters integer ( INT64 ), parameter :: TEMPERING_B = - 1658038656_INT64 integer ( INT64 ), parameter :: TEMPERING_C = - 272236544_INT64 ! Note: variable names match those in original example integer ( INT32 ) :: kk ! Generate N words at a time if ( state % mti >= N ) then ! The value -1 acts as a flag saying that the seed has not been set. if ( state % mti == - 1 ) call mtprng_init ( 4357_INT32 , state ) ! Fill the mt array do kk = 0 , N - M - 1 r = ior ( iand ( state % mt ( kk ), UPPER_MASK ), iand ( state % mt ( kk + 1 ), LOWER_MASK )) state % mt ( kk ) = ieor ( ieor ( state % mt ( kk + M ), ishft ( r , - 1_INT64 )), mag01 ( iand ( r , 1_INT64 ))) enddo do kk = N - M , N - 2 r = ior ( iand ( state % mt ( kk ), UPPER_MASK ), iand ( state % mt ( kk + 1 ), LOWER_MASK )) state % mt ( kk ) = ieor ( ieor ( state % mt ( kk + ( M - N )), ishft ( r , - 1_INT64 )), mag01 ( iand ( r , 1_INT64 ))) enddo r = ior ( iand ( state % mt ( N - 1 ), UPPER_MASK ), iand ( state % mt ( 0 ), LOWER_MASK )) state % mt ( N - 1 ) = ieor ( ieor ( state % mt ( M - 1 ), ishft ( r , - 1 )), mag01 ( iand ( r , 1_INT64 ))) ! Start using the array from first element state % mti = 0 endif ! Here is where we actually calculate the number with a series of !   transformations r = state % mt ( state % mti ) state % mti = state % mti + 1 !------------------------- !!r = ieor(r,ishft(r,-11)) r = ieor ( r , ishft ( iand ( 4294967295_INT64 , r ), - 11 )) ! Added a 32-bit mask to first r shift !------------------------- r = iand ( 4294967295_INT64 , ieor ( r , iand ( ishft ( r , 7 ), TEMPERING_B ))) r = iand ( 4294967295_INT64 , ieor ( r , iand ( ishft ( r , 15 ), TEMPERING_C ))) r = ieor ( r , ishft ( r , - 18 )) end function mtprng_rand64 !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! end module M_uuid","tags":"","url":"sourcefile/m_uuid.f90.html"},{"title":"test_suite_M_uuid.f90 – M_uuid","text":"Source Code module M_test_suite_M_uuid use M_framework__msg use M_framework__verify , only : unit_check , unit_check_start , unit_check_good , unit_check_bad , unit_check_done use M_uuid , only : generate_uuid private public test_suite_m_uuid contains subroutine test_suite_m_uuid () ! this should contains tests for all public procedures in the module call test_generate_uuid () end subroutine test_suite_m_uuid !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! subroutine test_generate_uuid () !   This just checks that we can generate the various types of UUID !   (without crashing) and checks that they have the correct syntax. We !   could also check that the UUID changes for each call and I think there !   is an additional check we could make within the UUID itself. But for !   now this is enough. character ( len = 36 ) :: uuid call unit_check_start ( 'generate_uuid' ) ! start tests uuid = generate_uuid ( 0 ) call unit_check ( 'generate_uuid' , check_uuid ( uuid ). and .( uuid == '00000000-0000-0000-0000-000000000000' ), msg = 'Version 0 ' // uuid ) uuid = generate_uuid ( 1 ) call unit_check ( 'generate_uuid' , check_uuid ( uuid ), msg = 'Version 1 ' // uuid ) uuid = generate_uuid ( 2 ) call unit_check ( 'generate_uuid' , uuid == '' , msg = 'Version 2 (NOT IMPLEMENTED)' ) uuid = generate_uuid ( 3 ) call unit_check ( 'generate_uuid' , uuid == '' , msg = 'Version 3 (NOT IMPLEMENTED)' ) uuid = generate_uuid ( 4 ) call unit_check ( 'generate_uuid' , check_uuid ( uuid ), msg = 'Version 4 ' // uuid ) uuid = generate_uuid ( 5 ) call unit_check ( 'generate_uuid' , uuid == '' , msg = 'Version 5 (NOT IMPLEMENTED)' ) call unit_check ( 'compare' , exercise ( 1000000 ), msg = 'test for duplicates in 1000000 values' ) call unit_check_done ( 'generate_uuid' ) !==================================================================================================================================! contains !==================================================================================================================================! function check_uuid ( chars ) result ( lout ) ! Return true if the string is permitted by the UUID BFN in RFC character ( len =* ) :: chars character ( len = 22 ), parameter :: hex = '0123456789abcdefABCDEF' logical :: lout lout = ( len_trim ( chars ) == 36 ) if ( lout ) then lout = lout . and .( verify ( chars ( 1 : 8 ), hex ) == 0 ) lout = lout . and .( verify ( chars ( 9 : 9 ), '-' ) == 0 ) lout = lout . and .( verify ( chars ( 10 : 13 ), hex ) == 0 ) lout = lout . and .( verify ( chars ( 14 : 14 ), '-' ) == 0 ) lout = lout . and .( verify ( chars ( 15 : 18 ), hex ) == 0 ) lout = lout . and .( verify ( chars ( 19 : 19 ), '-' ) == 0 ) lout = lout . and .( verify ( chars ( 20 : 23 ), hex ) == 0 ) lout = lout . and .( verify ( chars ( 24 : 24 ), '-' ) == 0 ) lout = lout . and .( verify ( chars ( 25 : 36 ), hex ) == 0 ) endif end function check_uuid !==================================================================================================================================! end subroutine test_generate_uuid !==================================================================================================================================! function exercise ( sz ) logical :: exercise integer :: sz character ( len = 36 ), allocatable :: uuid (:) integer :: i , j integer :: icount exercise = . true . TYPES : do j = 1 , 4 , 3 if ( allocated ( uuid )) deallocate ( uuid ) allocate ( uuid ( sz )) do i = 1 , sz uuid ( i ) = generate_uuid ( j ) enddo call sort_shell_strings_lh ( uuid ) call unique_strings ( uuid , icount ) if ( icount . ne . size ( uuid )) then exercise = . false . exit TYPES endif enddo TYPES end function exercise !==================================================================================================================================! subroutine sort_shell_strings_lh ( lines ) ! ident_5=\"@(#)M_sort::sort_shell_strings_lh(3fp):sort strings(a-z) over specified field using shell sort\" character ( len =* ) :: lines (:) character ( len = :), allocatable :: ihold integer :: n , igap , i , j , k , jg n = size ( lines ) if ( n . gt . 0 ) then allocate ( character ( len = len ( lines ( 1 ))) :: ihold ) else ihold = '' endif igap = n INFINITE : do igap = igap / 2 if ( igap . eq . 0 ) exit INFINITE k = n - igap i = 1 INNER : do j = i INSIDE : do jg = j + igap if ( lle ( lines ( j ), lines ( jg ))) exit INSIDE ihold = lines ( j ) lines ( j ) = lines ( jg ) lines ( jg ) = ihold j = j - igap if ( j . lt . 1 ) exit INSIDE enddo INSIDE i = i + 1 if ( i . gt . k ) exit INNER enddo INNER enddo INFINITE end subroutine sort_shell_strings_lh subroutine unique_strings ( array , ivals ) character ( len =* ), intent ( inout ), allocatable :: array (:) integer , intent ( out ) :: ivals integer :: i , isize isize = size ( array ) if ( isize . ge . 2 ) then ivals = 1 do i = 2 , isize if ( array ( i ). ne . array ( i - 1 )) then ivals = ivals + 1 else write ( * , * ) '<ERROR> at ' , i , ' and ' , i + 1 , ' duplicates ' , array ( i ) endif enddo else ivals = isize endif end subroutine unique_strings !==================================================================================================================================! end module M_test_suite_M_uuid !==================================================================================================================================! program runtest use M_framework__msg use M_framework__verify , only : unit_check_stop use M_test_suite_M_uuid implicit none call test_suite_M_uuid () call unit_check_stop () end program runtest !==================================================================================================================================!","tags":"","url":"sourcefile/test_suite_m_uuid.f90.html"}]}